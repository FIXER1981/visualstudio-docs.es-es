---
title: Advertencias de seguridad
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 004f10600df3ed2f9c1f62557e0915638482877e
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/01/2020
ms.locfileid: "75587217"
---
# <a name="security-warnings"></a>Advertencias de seguridad

Las advertencias de seguridad son compatibles con las bibliotecas y aplicaciones más seguras. Estas advertencias ayudan a evitar los errores de seguridad en su programa. Si deshabilita cualquier advertencia de este tipo, se debe indicar el motivo claramente en el código además de informar al responsable de seguridad designado a ese proyecto de desarrollo.

## <a name="in-this-section"></a>En esta sección

|Regla|Descripción|
|----------|-----------------|
|[CA2100: Revisar consultas SQL para comprobar si tienen vulnerabilidades de seguridad](../code-quality/ca2100.md)|Un método establece la propiedad System.Data.IDbCommand.CommandText utilizando una cadena que se construye partiendo de un argumento de cadena para el método. Esta regla supone que el argumento de cadena contiene datos proporcionados por el usuario. Una cadena de comandos de SQL compilada a partir de datos proporcionados por el usuario es vulnerable a ataques de inserción de SQL.|
|[CA2102: Detectar las excepciones que no son CLSCompliant en los controladores generales](../code-quality/ca2102.md)|Un miembro de un ensamblado que no está marcado con el atributo RuntimeCompatibilityAttribute o está marcado con RuntimeCompatibility(WrapNonExceptionThrows = false) contiene un bloque catch que controla el objeto System.Exception y no contiene un bloque catch general inmediatamente después.|
|[CA2103: Revisar la seguridad imperativa](../code-quality/ca2103.md)|Un método utiliza la seguridad imperativa y podría estar creando el permiso utilizando la información de estado y los valores devueltos que pueden cambiar mientras la solicitud está activa. Utilice la seguridad declarativa siempre que sea posible.|
|[CA2104: No declarar tipos de referencias mutables de solo lectura](../code-quality/ca2104.md)|Un tipo visible externamente contiene un campo de sólo lectura visible externamente que es un tipo de referencia que se puede cambiar. Un tipo que mutable es un tipo cuyos datos de instancia se pueden modificar.|
|[CA2105: Los campos de matrices no deberían ser de solo lectura](../code-quality/ca2105.md)|Cuando se aplica el modificador de solo lectura (ReadOnly en Visual Basic) a un campo que contiene una matriz, el campo no se puede modificar para hacer referencia a una matriz distinta. Sin embargo, se pueden cambiar los elementos de la matriz almacenados en un campo de sólo lectura.|
|[CA2106: Asegurar aserciones](../code-quality/ca2106.md)|Un método valida un permiso y no se realiza ninguna comprobación de seguridad en el llamador. Validar un permiso de seguridad sin realizar ninguna comprobación de seguridad puede dejar una debilidad de seguridad explotable en el código.|
|[CA2107: Revisar el uso de Deny y PermitOnly](../code-quality/ca2107.md)|Usar el método PermitOnly y CodeAccessPermission. deny las acciones de seguridad solo las deben usar los usuarios con conocimientos avanzados de seguridad de .NET. Debería realizarse una revisión de la seguridad del código que utiliza estas acciones de seguridad.|
|[CA2108: Revisar la seguridad declarativa en los tipos de valores](../code-quality/ca2108.md)|Un tipo de valor público o protegido está protegido por acceso a datos o peticiones de vínculos.|
|[CA2109: Revisar los controladores de eventos visibles](../code-quality/ca2109.md)|Se detectó un método de control de eventos público o protegido. No se deberían exponer los métodos de control de eventos a menos que sea absolutamente necesario.|
|[CA2111: Los punteros no deberían estar visibles](../code-quality/ca2111.md)|Un puntero no es privado, interno ni de solo lectura. El código malintencionado puede cambiar el valor del puntero, permitiendo potencialmente el acceso a ubicaciones arbitrarias en memoria o provocando errores del sistema o de aplicación.|
|[CA2112: Los tipos seguros no deberían exponer campos](../code-quality/ca2112.md)|Un tipo público o protegido contiene campos públicos y está protegido por peticiones de vínculos. Si el código tiene acceso a una instancia de tipo que está protegida por una solicitud de vínculo, el código no cumplirá la solicitud para obtener acceso a los campos del tipo.|
|[CA2114: La seguridad del método debería ser un supraconjunto del tipo](../code-quality/ca2114.md)|Un método no debe tener seguridad declarativa en el nivel de método y de tipo para la misma acción.|
|[CA2115: Llamar a GC.KeepAlive cuando se utilicen recursos nativos](../code-quality/ca2115.md)|Esta regla detecta errores que pueden haberse producido porque se finaliza un recurso no administrado mientras todavía se utiliza en código no administrado.|
|[CA2116: Los métodos APTCA deben llamar solo a métodos APTCA](../code-quality/ca2116.md)|Si está presente el atributo APTCA (AllowPartiallyTrustedCallers) en un ensamblado de plena confianza y el ensamblado ejecuta código en otro ensamblado que permite llamadores parcialmente confiables, se puede producir un ataque en el sistema de seguridad.|
|[CA2117: Los tipos APTCA solo amplían tipos base APTCA](../code-quality/ca2117.md)|Si está presente el atributo APTCA (AllowPartiallyTrustedCallers) en un ensamblado de plena confianza y un tipo del ensamblado se hereda de otro que permite llamadores parcialmente confiables, se puede producir un ataque de seguridad.|
|[CA2118: Revisar el uso de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute cambia el comportamiento del sistema de seguridad predeterminado por miembros que ejecutan código no administrado que utiliza la interoperabilidad COM o la invocación de plataforma. Este atributo se utiliza principalmente para aumentar el rendimiento; sin embargo, las mejoras de rendimiento suponen riesgos de seguridad importantes.|
|[CA2119: Sellar los métodos que satisfacen las interfaces privadas](../code-quality/ca2119.md)|Un tipo público heredable proporciona una implementación de método reemplazable de una interfaz interna (de tipo "Friend" en Visual Basic). Para corregir una infracción de esta regla, impida que el método se invalide fuera del ensamblado.|
|[CA2120: Proteger los constructores de serializaciones](../code-quality/ca2120.md)|Este tipo tiene un constructor que toma un objeto System.Runtime.Serialization.SerializationInfo y un objeto System.Runtime.Serialization.StreamingContext (la firma del constructor de serialización). Una comprobación de seguridad no protege este constructor, pero protege uno o más constructores regulares del tipo.|
|[CA2121: Los constructores estáticos deberían ser privados](../code-quality/ca2121.md)|El sistema llama al constructor estático antes de crear la primera instancia del tipo o antes de hacer referencia a cualquier miembro estático. Si un constructor estático no es privado, se puede llamar a través de un código distinto del sistema. En función de las operaciones que se realizan en el constructor, esto puede producir un comportamiento inesperado.|
|[CA2122: No exponer indirectamente métodos con peticiones de vínculos](../code-quality/ca2122.md)|Un miembro público o protegido tiene peticiones de vínculos y lo llama un miembro que no realiza ninguna comprobación de seguridad. Una solicitud de vínculo sólo comprueba los permisos del llamador inmediato.|
|[CA2123: Las peticiones de vínculo de invalidaciones deberían ser idénticas a la base](../code-quality/ca2123.md)|Esta regla compara un método con su método base, que es una interfaz o un método virtual de otro tipo y, a continuación, compara las solicitudes de vínculos en cada uno. Si se infringe esta regla, un llamador malintencionado puede omitir la petición de vínculo tan solo con llamar al método no seguro.|
|[CA2124: Incluir cláusulas finally vulnerables en un bloque try externo](../code-quality/ca2124.md)|Un método público o protegido contiene un bloque try/finally. El bloque finally aparece para restablecer el estado de seguridad y no se incluye a sí mismo en un bloque finally.|
|[CA2126: Las peticiones de vínculos de tipos requieren peticiones de herencias](../code-quality/ca2126.md)|Un tipo público no sellado está protegido con una petición de vínculo y tiene un método reemplazable. Ni el tipo ni el método están protegidos con una petición de herencia.|
|[CA2130: Las constantes críticas para la seguridad deben ser transparentes](../code-quality/ca2130.md)|El cumplimiento de la transparencia no se exige para los valores constantes porque los compiladores alinean los valores constantes para que no se requiera ninguna búsqueda en tiempo de ejecución. Los campos constantes deberían ser transparentes en seguridad de modo que los revisores del código no supongan que el código transparente no puede tener acceso a la constante.|
|[CA2131: Los tipos críticos para la seguridad no pueden participar en la equivalencia de tipos](../code-quality/ca2131.md)|Un tipo participa en la equivalencia de tipos y el propio tipo, o un miembro o campo del tipo, se marca con el atributo SecurityCriticalAttribute. Esta regla se produce en todos los tipos críticos o en los tipos que contienen métodos o campos críticos que participan en la equivalencia de tipos. Cuando CLR detecta esta clase de tipo, no lo carga con TypeLoadException en tiempo de ejecución. Normalmente, esta regla solo se desencadena cuando los usuarios implementan la equivalencia de tipos manualmente en lugar de confiar en tlbimp y los compiladores para hacer la equivalencia de tipos.|
|[CA2132: Los constructores predeterminados deben ser al menos tan críticos para la seguridad como los constructores predeterminados de tipo base](../code-quality/ca2132.md)|El código de la aplicación Silverlight no puede usar los tipos y miembros con SecurityCriticalAttribute. El código de confianza puede utilizar solo tipos y miembros críticos para la seguridad en .NET Framework para la biblioteca de clases de Silverlight. Dado que una construcción pública o protegida en una clase derivada debe tener la misma transparencia, o mayor, que su clase base, una clase de una aplicación no puede derivar de una clase marcada como SecurityCritical.|
|[CA2133: Los delegados deben enlazarse a métodos con una transparencia coherente](../code-quality/ca2133.md)|Esta advertencia se desencadena en un método que enlaza un delegado que se marca con SecurityCriticalAttribute a un método que es transparente o que está marcado con SecuritySafeCriticalAttribute. La advertencia también desencadena un método que enlaza un delegado que es transparente o crítico para la seguridad a un método crítico.|
|[CA2134: Los métodos deben mantener una transparencia coherente al invalidar métodos base](../code-quality/ca2134.md)|Esta regla se desencadena cuando un método marcado con SecurityCriticalAttribute invalida un método que es transparente o está marcado con SecuritySafeCriticalAttribute. Esta regla también se desencadena cuando un método marcado con SecuritySafeCriticalAttribute invalida un método que es transparente o está marcado con SecurityCriticalAttribute. Se aplica la regla al invalidar un método virtual o implementar una interfaz.|
|[CA2135: Los ensamblados de nivel 2 no deben contener LinkDemands](../code-quality/ca2135.md)|LinkDemands está desusado en el conjunto de reglas de seguridad de nivel 2. En lugar de utilizar LinkDemands para exigir la seguridad en el momento de la compilación Just-In-Time (JIT), marque los métodos, tipos y campos con el atributo SecurityCriticalAttribute.|
|[CA2136: Los miembros no deben tener anotaciones de transparencia en conflicto](../code-quality/ca2136.md)|Los atributos de transparencia se aplican de los elementos de código de ámbito mayor a los elementos de ámbito menor. Los atributos de transparencia de los elementos de código con mayor ámbito tienen prioridad sobre los atributos de transparencia de los elementos de código incluidos en el primer elemento. Por ejemplo, una clase marcada con el atributo SecurityCriticalAttribute no puede contener un método marcado con el atributo SecuritySafeCriticalAttribute.|
|[CA2137: Los métodos transparentes deben contener solo IL que se pueda comprobar](../code-quality/ca2137.md)|Un método contiene código que no se puede comprobar o devuelve un tipo por referencia. Esta regla se desencadena en los intentos del código transparente en seguridad de ejecutar MSIL no comprobable (Lenguaje intermedio de Microsoft). Sin embargo, la regla no contiene un comprobador de IL completo y, en su lugar, utiliza la heurística para detectar la mayoría de las infracciones de comprobación MSIL.|
|[CA2138: Los métodos transparentes no deben llamar a métodos con el atributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Un método transparente en seguridad llama a un método marcado con el atributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Los métodos transparentes no pueden usar el atributo HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Esta regla se desencadena en cualquier método que sea transparente e intenta controlar una excepción de daño de proceso mediante el atributo HandleProcessCorruptedStateExceptionsAttribute. Una excepción de daño de proceso es una clasificación de excepción de CLR versión 4,0 de excepciones como <xref:System.AccessViolationException>. El atributo HandleProcessCorruptedStateExceptionsAttribute solo lo pueden utilizar los métodos críticos para la seguridad, y se omitirá si se aplica a un método transparente.|
|[CA2140: El código transparente no debe hacer referencia a elementos críticos para la seguridad](../code-quality/ca2140.md)|Los métodos que se marcan con el atributo SecurityTransparentAttribute llaman a miembros no públicos marcados como SecurityCritical. Esta regla analiza todos los métodos y tipos de un ensamblado que tiene una mezcla de transparente y crítico, y marca las llamadas desde código transparente a código crítico no público que no están marcadas como SecurityTreatAsSafe.|
|[CA2141: Los métodos transparentes no deben satisfacer LinkDemands](../code-quality/ca2141.md)|Un método transparente en seguridad llama a un método de un ensamblado no marcado con APTCA (AllowPartiallyTrustedCallersAttribute) o bien satisface un LinkDemand para un tipo o un método.|
|[CA2142: El código transparente no debe protegerse con LinkDemands](../code-quality/ca2142.md)|Esta regla se desencadena en los métodos transparentes que requieren que las LinkDemand tengan acceso a ellos. El código transparente en seguridad no debería ser responsable de comprobar la seguridad de una operación y, por consiguiente, no debería exigir permisos.|
|[CA2143: Los métodos transparentes no deben usar peticiones de seguridad](../code-quality/ca2143.md)|El código transparente en seguridad no debería ser responsable de comprobar la seguridad de una operación y, por consiguiente, no debería exigir permisos. El código transparente en seguridad debería utilizar peticiones completas para tomar decisiones de seguridad y el código crítico para la seguridad no debió confiar en el código transparente al realizar la petición completa.|
|[CA2144: El código transparente no debe cargar ensamblados desde matrices de bytes](../code-quality/ca2144.md)|La revisión de seguridad del código transparente no es tan exhaustiva como la revisión de seguridad del código crítico, porque el código transparente no puede realizar acciones que afectan a la seguridad. Los ensamblados cargados desde una matriz de bytes podrían no distinguirse en el código transparente, y esa matriz de bytes podría contener código importante crítico para la seguridad, que no hace falta auditar.|
|[CA2145: Los métodos transparentes no deben ser representativos con el atributo SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Los métodos decorados con el atributo SuppressUnmanagedCodeSecurityAttribute tienen una LinkDemand implícita colocada en cualquier método que la llame. Esta LinkDemand requiere que el código de llamada sea crítico para la seguridad. Marcar el método que utiliza SuppressUnmanagedCodeSecurity con el atributo SecurityCriticalAttribute hace este requisito más obvio para los llamadores del método.|
|[CA2146: Los tipos deben ser al menos tan críticos para la seguridad como sus interfaces y tipos base](../code-quality/ca2146.md)|Esta regla se desencadena cuando un tipo derivado tiene un atributo de transparencia de seguridad que no es tan crítico como su tipo base o interfaz implementada. Solo los tipos críticos pueden derivar de los tipos base críticos o implementar interfaces críticas, y solo los tipos críticos o críticos para la seguridad pueden derivar de tipos base críticos para la seguridad o implementar interfaces críticas para la seguridad.|
|[CA2147: Los métodos transparentes no pueden usar aserciones de seguridad](../code-quality/ca2147.md)|Esta regla analiza todos los métodos y tipos de un ensamblado que es 100% transparente o tiene una mezcla de transparente y crítico, y marca cualquier uso declarativo o imperativo de Assert.|
|[CA2149: Los métodos transparentes no deben llamar a código nativo](../code-quality/ca2149.md)|Esta regla se desencadena en cualquier método transparente que llame directamente a código nativo, por ejemplo, a través de P/Invoke. Las infracciones de esta regla tienen como resultado una excepción MethodAccessException en el modelo de transparencia de nivel 2 y una demanda completa de UnmanagedCode en el modelo de transparencia de nivel 1.|
|[CA2151: Los campos con tipos críticos deben ser críticos para la seguridad](../code-quality/ca2151.md)|Para utilizar tipos críticos para la seguridad, el código que hace referencia al tipo debe ser crítico para la seguridad o crítico para la seguridad y disponible desde código transparente. Esto es así incluso si la referencia es indirecta. Por consiguiente, tener un campo transparente para la seguridad o crítico para la seguridad y disponible desde código transparente puede llevar a confusión, porque el código transparente todavía no podrá tener acceso al campo.|
|[CA2153: Avoid Handling Corrupted State Exceptions (Evitar el control de excepciones de estado dañadas)](../code-quality/ca2153.md)|Las[excepciones de estado dañado (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indican que la memoria está dañada en el proceso. Detectar estos problemas y evitar el bloqueo del proceso puede provocar vulnerabilidades de seguridad si un atacante puede colocar una vulnerabilidad de seguridad en la región de memoria dañada.|
|[CA2300: no usar deserializador no seguro BinaryFormatter](../code-quality/ca2300.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2301: no llamar a BinaryFormatter. Deserialize sin establecer primero BinaryFormatter. Binder](../code-quality/ca2301.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2302: Asegúrese de que BinaryFormatter. Binder se establezca antes de llamar a BinaryFormatter. Deserialize](../code-quality/ca2302.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2305: no usar deserializador no seguro LosFormatter](../code-quality/ca2305.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2310: no usar deserializador no seguro NetDataContractSerializer](../code-quality/ca2310.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2311: no deserializar sin establecer primero NetDataContractSerializer. Binder](../code-quality/ca2311.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2312: Asegúrese de que NetDataContractSerializer. Binder se establezca antes de la deserialización.](../code-quality/ca2312.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2315: no usar deserializador no seguro ObjectStateFormatter](../code-quality/ca2315.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2321: no deserializar con JavaScriptSerializer mediante SimpleTypeResolver](../code-quality/ca2321.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2322: Asegúrese de que JavaScriptSerializer no se ha inicializado con SimpleTypeResolver antes de la deserialización.](../code-quality/ca2322.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2326: no use valores TypeNameHandling distintos de None](../code-quality/ca2326.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2327: no usar JsonSerializerSettings inseguro](../code-quality/ca2327.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2328: Asegúrese de que JsonSerializerSettings sean seguros.](../code-quality/ca2328.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2329: no deserializar con JsonSerializer mediante una configuración no segura](../code-quality/ca2329.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2330: Asegúrese de que JsonSerializer tiene una configuración segura al deserializar](../code-quality/ca2330.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA3001: revisar el código para las vulnerabilidades de inyección de código SQL](../code-quality/ca3001.md)|Al trabajar con comandos SQL y de entrada que no son de confianza, tenga en cuentan los ataques por inyección de SQL. Un ataque por inyección de SQL puede ejecutar comandos SQL malintencionados, poniendo en peligro la seguridad y la integridad de la aplicación.|
|[CA3002: revisar el código para detectar vulnerabilidades XSS](../code-quality/ca3002.md)|Al trabajar con una entrada que no es de confianza de las solicitudes Web, tenga en cuentan los ataques de scripting entre sitios (XSS). Un ataque XSS inyecta entradas que no son de confianza en salidas HTML sin procesar, lo que permite al atacante ejecutar scripts malintencionados o modificar contenido de forma malintencionada en la Página Web.|
|[CA3003: revisar el código para detectar vulnerabilidades de inyección de rutas de archivo](../code-quality/ca3003.md)|Al trabajar con una entrada que no es de confianza de las solicitudes Web, tenga en cuentan el uso de entradas controladas por el usuario al especificar las rutas de acceso a los archivos.|
|[CA3004: revisar el código para detectar vulnerabilidades de divulgación de información](../code-quality/ca3004.md)|Al revelar la información de la excepción, se ofrece a los atacantes información sobre el funcionamiento interno de la aplicación, lo que puede ayudar a los atacantes a encontrar otras vulnerabilidades que se puedan aprovechar.|
|[CA3006: revisar el código para detectar vulnerabilidades de inyección de comandos de proceso](../code-quality/ca3006.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de comandos. Un ataque por inyección de comandos puede ejecutar comandos malintencionados en el sistema operativo subyacente, poniendo en peligro la seguridad y la integridad del servidor.|
|[CA3007: revisar el código para detectar vulnerabilidades de redireccionamiento abierto](../code-quality/ca3007.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan las vulnerabilidades de redireccionamiento abierto. Un atacante puede aprovechar una vulnerabilidad de redirección abierta para usar el sitio web con el fin de dar la apariencia de una dirección URL legítima, pero redirigir a un visitante que no sospecha a un phishing u otra página web malintencionada.|
|[CA3008: revisar el código para las vulnerabilidades de inyección de XPath](../code-quality/ca3008.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XPath. La construcción de consultas XPath mediante la entrada que no es de confianza puede permitir a un atacante manipular de forma malintencionada la consulta para devolver un resultado no deseado y, posiblemente, divulgar el contenido del XML consultado.|
|[CA3009: revisar el código para detectar vulnerabilidades de inyección XML](../code-quality/ca3009.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XML.|
|[CA3010: revisar el código para las vulnerabilidades de inyección de XAML](../code-quality/ca3010.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XAML. XAML es un lenguaje de marcado que representa directamente la creación de instancias y la ejecución de objetos. Esto significa que los elementos creados en XAML pueden interactuar con los recursos del sistema (por ejemplo, el acceso a la red y la e/s del sistema de archivos).|
|[CA3011: revisar el código para detectar vulnerabilidades de inyección de DLL](../code-quality/ca3011.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan la carga de código que no es de confianza. Si la aplicación web carga código que no es de confianza, es posible que un atacante pueda insertar archivos dll malintencionados en el proceso y ejecutar código malintencionado.|
|[CA3012: revisar el código para detectar vulnerabilidades de inyección de Regex](../code-quality/ca3012.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de Regex. Un atacante puede usar la inyección de Regex para modificar de forma malintencionada una expresión regular, para hacer que el regex coincida con los resultados imprevistos o para hacer que la expresión regular consuma una CPU excesiva, lo que produce un ataque de denegación de servicio.|
|[CA3061: no agregar esquema por dirección URL](../code-quality/ca3061.md)|No use la sobrecarga no segura del método Add porque puede provocar referencias externas peligrosas.|
|[CA3075: Insecure DTD Processing (Procesamiento no seguro de la DTD)](../code-quality/ca3075.md)|Si usa instancias de DTDProcessing inseguras o hace referencia a orígenes de entidades externas, el analizador podría aceptar entradas que no sean de confianza y revelar información confidencial a atacantes.|
|[CA3076: Insecure XSLT Script Execution (Ejecución del script XSLT no segura)](../code-quality/ca3076.md)|Si ejecuta el lenguaje de transformación basado en hojas de estilo (XSLT) en aplicaciones .NET de forma no segura, el procesador podría resolver referencias URI que no sean de confianza y que podrían revelar información confidencial a atacantes, lo que daría lugar a ataques de denegación de servicio y entre sitios.|
|[CA3077: procesamiento inseguro en el diseño de una API, documento XML y lector de texto XML](../code-quality/ca3077.md)|Al diseñar una API derivada de XMLDocument y XMLTextReader, tenga en cuenta la propiedad DtdProcessing. El uso de instancias de DTDProcessing inseguras al hacer referencia a orígenes de entidades externas o resolverlos, o la definición de valores inseguros en el lenguaje XML puede provocar la divulgación de información.|
|[CA3147: Marque los controladores de verbo con ValidateAntiForgeryToken](../code-quality/ca3147.md)|Al diseñar un controlador ASP.NET MVC, tenga en cuentan los ataques de falsificación de solicitudes entre sitios. Un ataque de falsificación de solicitudes entre sitios puede enviar solicitudes malintencionadas de un usuario autenticado a su controlador ASP.NET MVC.|
|[CA5122: Las declaraciones P/Invoke no deben ser críticas para la seguridad](../code-quality/ca5122.md)|Los métodos se marcan como SecuritySafeCritical cuando realizan una operación que afecta a la seguridad pero también son seguros para su uso en código transparente. El código transparente nunca puede llamar a código nativo a través de P/Invoke. Por consiguiente, aunque se marque P/Invoke como crítico para la seguridad y disponible desde código transparente no permitirá que se llame desde código transparente llamarlo, y es erróneo para los análisis de seguridad.|
|[CA5361: no deshabilite el uso de SChannel de cifrado seguro](../code-quality/ca5361.md)|Establecer `Switch.System.Net.DontEnableSchUseStrongCrypto` en `true` debilita la criptografía utilizada en las conexiones de seguridad de la capa de transporte (TLS). La criptografía más débil puede poner en peligro la confidencialidad de la comunicación entre la aplicación y el servidor, lo que facilita a los atacantes la interceptación de información confidencial.|
|[CA5363: no deshabilitar la validación de solicitudes](../code-quality/ca5363.md)|La validación de solicitudes es una característica de ASP.NET que examina las solicitudes HTTP y determina si contienen contenido potencialmente peligroso que puede conducir a ataques de inyección, incluido el scripting entre sitios.|
|[CA5364: no usar protocolos de seguridad en desuso](../code-quality/ca5364.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo anteriores de TLS son menos seguras que las de TLS 1,2 y TLS 1,3 y es más probable que tengan nuevas vulnerabilidades. Evite las versiones anteriores del protocolo para minimizar el riesgo.|
|[CA5369: usar XmlReader para la deserialización](../code-quality/ca5369.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas, que se deben restringir mediante un XmlReader con un solucionador seguro o con el procesamiento de esquemas en línea XML y DTD deshabilitado.|
|[CA5370: usar XmlReader para validar el lector](../code-quality/ca5370.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas. Esta carga peligrosa se puede restringir mediante el uso de un XmlReader con un solucionador seguro o con el procesamiento de esquemas en línea de DTD y XML deshabilitado.|
|[CA5371: usar XmlReader para leer el esquema](../code-quality/ca5371.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas. El uso de un XmlReader con un solucionador seguro o con DTD y el procesamiento de esquemas en línea XML deshabilitado restringe esto.|
|[CA5372: uso de XmlReader para XPathDocument](../code-quality/ca5372.md)|El procesamiento de XML a partir de datos que no son de confianza puede cargar referencias externas peligrosas, que se pueden restringir mediante un XmlReader con un solucionador seguro o con el procesamiento de DTD deshabilitado.|
|[CA5373: no usar la función de derivación de clave obsoleta](../code-quality/ca5373.md)|Esta regla detecta la invocación de métodos de derivación de claves débiles <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> y `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> usar un algoritmo débil del PBKDF1.|
|[CA5378: no deshabilitar ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Establecer `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` en `true` limita las conexiones de seguridad de la capa de transporte (TLS) de Windows Communication Framework (WCF) al uso de TLS 1,0. Esa versión de TLS quedará en desuso.|
|[CA5380: no agregar certificados al almacén raíz](../code-quality/ca5380.md)|Esta regla detecta código que agrega un certificado al almacén de certificados de entidades de certificación raíz de confianza. De forma predeterminada, el almacén de certificados de entidades de certificación raíz de confianza se configura con un conjunto de entidades de certificación públicas que cumplen los requisitos del programa de certificados raíz de Microsoft.|
|[CA5381: Asegúrese de que no se agregan certificados al almacén raíz](../code-quality/ca5381.md)|Esta regla detecta código que puede Agregar un certificado al almacén de certificados de entidades de certificación raíz de confianza. De forma predeterminada, el almacén de certificados de entidades de certificación raíz de confianza se configura con un conjunto de entidades de certificación (CA) públicas que cumplen los requisitos del programa de certificados raíz de Microsoft.|
|[CA5386: evitar el valor de codificar SecurityProtocolType](../code-quality/ca5386.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo TLS 1,0 y TLS 1,1 están desusadas, mientras que TLS 1,2 y TLS 1,3 están actualizados. En el futuro, TLS 1,2 y TLS 1,3 pueden estar en desuso. Para asegurarse de que la aplicación sigue siendo segura, evite codificar una versión del protocolo y tenga como destino al menos .NET Framework v 4.7.1.|
|[CA5389: no agregar la ruta de acceso del elemento de almacenamiento a la ruta de acceso del sistema de archivos de destino](../code-quality/ca5389.md)|La ruta de acceso de archivo puede ser relativa y puede dar lugar a un acceso al sistema de archivos fuera de la ruta de destino del sistema de archivos esperada, lo que provoca cambios de configuración malintencionados y la ejecución remota de código mediante la técnica de establecer y esperar.|
|[CA5397: no usar valores SslProtocols desusados](../code-quality/ca5397.md)|la seguridad de nivel de ransport (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo anteriores de TLS son menos seguras que las de TLS 1,2 y TLS 1,3 y es más probable que tengan nuevas vulnerabilidades. Evite las versiones anteriores del protocolo para minimizar el riesgo.|
|[CA5398: Evite valores SslProtocols codificados](../code-quality/ca5398.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo TLS 1,0 y TLS 1,1 están desusadas, mientras que TLS 1,2 y TLS 1,3 están actualizados. En el futuro, TLS 1,2 y TLS 1,3 pueden estar en desuso. Para asegurarse de que la aplicación sigue siendo segura, evite codificar una versión del protocolo.|
