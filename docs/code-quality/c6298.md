---
title: C6298
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6298
helpviewer_keywords:
- C6298
ms.assetid: 986dc8e7-8596-4223-a66f-8616357d4399
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 30ed01b01a08e361dd2c19759a795362ec3d433d
ms.sourcegitcommit: 174c992ecdc868ecbf7d3cee654bbc2855aeb67d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/06/2019
ms.locfileid: "74878221"
---
# <a name="c6298"></a>C6298
ADVERTENCIA C6298: el uso de una cadena de solo lectura \<puntero > como argumento de cadena grabable: intentará escribir en la memoria estática de solo lectura y provocará bloqueos aleatorios.

 Esta advertencia indica el uso de una cadena de constante como argumento para una función que podría modificar el contenido de esa cadena. Dado que el compilador asigna cadenas constantes en una memoria estática de solo lectura, todos los intentos de modificarla provocan infracciones de acceso y bloqueos aleatorios.

 Esto puede evitarse si se almacena la cadena de constante en una matriz local y, a continuación, se usa la matriz como argumento para la función.

## <a name="example"></a>Ejemplo
 El siguiente ejemplo de código genera esta advertencia:

```cpp
#include <windows.h>
#include <stdio.h>

void f()
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );
    ZeroMemory( &pi, sizeof( pi ) );
    if( !CreateProcess(NULL,
                      "\"c:\\Windows\\system32\\calc.exe\"",
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi ) )
    {
        puts( "CreateProcess failed." );
        return;
    }

    // Wait until child process exits.
    WaitForSingleObject( pi.hProcess, INFINITE );

    // Close process and thread handles.
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
}
```

 Para corregir esta advertencia, utilice el siguiente código de ejemplo:

```cpp
#include <windows.h>
#include <stdio.h>

void f( )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    char szCmdLine[] = "\"c:\\Windows\\system32\\calc.exe\"";
    ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );
    ZeroMemory( &pi, sizeof( pi ) );

    if( !CreateProcess(NULL,
                      szCmdLine,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi ) )
    {
        puts( "CreateProcess failed." );
        return;
    }

    // Wait until child process exits.
    WaitForSingleObject( pi.hProcess, INFINITE );

    // Close process and thread handles.
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
}
```
