---
title: C26417
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26417
helpviewer_keywords:
- C26417
ms.assetid: 0e09fcc6-f9eb-4404-b51e-5815705c6afb
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: a6ce30eb64ccb50f45cbe67b7a89ee0d13ba2bdb
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261019"
---
# <a name="c26417-no_lvalue_ref_shared_ptr"></a>NO_LVALUE_REF_SHARED_PTR C26417
"El parámetro de puntero compartido se pasa por referencia y no se restablece o reasigna. Use T * o T & en su lugar ".

Directrices básicas: R. 35: tomar un shared_ptr\<widget > & parámetro para expresar que una función puede volver a colocar el puntero compartido **C++**

Pasar punteros compartidos por referencia puede ser útil en escenarios en los que las actualizaciones de código del destinatario tienen como destino el objeto de puntero inteligente y su llamador espera ver esa actualización. El uso de una referencia únicamente para reducir los costos de pasar un puntero compartido es cuestionable. Si el código de destinatario solo tiene acceso al objeto de destino y nunca administra su duración, es más seguro pasar un puntero o referencia sin formato, en lugar de exponer los detalles de la administración de recursos.

## <a name="remarks"></a>Comentarios
- Esta comprobación reconoce STD:: shared_pointer y los tipos definidos por el usuario que es probable que se comporten como punteros compartidos. Se esperan los siguientes rasgos para los punteros compartidos definidos por el usuario:
- la desreferenciación sobrecargada o los operadores de acceso a miembros (públicos y no eliminados);
- constructor de copias o operador de asignación de copia (público y no eliminado);
- Destructor público que no se ha eliminado ni predeterminado. Los destructores vacíos se siguen contando como definidos por el usuario.
- La acción de restablecer o reasignar se interpreta de forma más genérica:
- cualquier llamada a una función no constante en un puntero compartido puede restablecer el puntero;
- cualquier llamada a una función que acepte una referencia a un puntero compartido no constante puede restablecer o volver a asignar ese puntero.

## <a name="example"></a>Ejemplo
complicación de interfaz innecesaria

```cpp
bool unregister(std::shared_ptr<event> &e) // C26417, also C26415 SMART_PTR_NOT_NEEDED
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e))
        e = std::make_shared<event>(e->id());
    // ...
}
```

## <a name="example"></a>Ejemplo
complicación de interfaz innecesaria: simplificada

```cpp
bool unregister(const event *e)
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e.get()))
        e = std::make_shared<event>(e->id());
    // ...
}
```
