---
title: C26429
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26429
helpviewer_keywords:
- C26429
ms.assetid: 4e1c74d5-7307-436c-927b-f74ae863282c
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: e3048fcf5c74a006a16a5e962f017651bcdd0b69
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/15/2020
ms.locfileid: "77260914"
---
# <a name="c26429-use_notnull"></a>USE_NOTNULL C26429

"Nunca se ha probado la nulaidad del símbolo, se puede marcar como GSL:: not_null".

Directrices básicas: F. 23: usar un not_null\<t > para indicar que "null" no es un valor válido **C++**

Es una práctica común usar aserciones para aplicar suposiciones sobre la validez de los valores de puntero. El problema con las aserciones es que no exponen suposiciones a través de la interfaz (por ejemplo, en tipos de valor devuelto o parámetros). Las aserciones también son más difíciles de mantener y se mantienen sincronizadas con otros cambios de código. La recomendación es usar GSL:: not_null de la biblioteca de compatibilidad de directrices como un marcador de recursos que nunca deben tener un valor null. La regla USE_NOTNULL ayuda a identificar los lugares que omiten las comprobaciones de NULL y, por lo tanto, se pueden actualizar para utilizar GSL:: not_null.

## <a name="remarks"></a>Comentarios

- La lógica de la regla requiere código para Desreferenciar una variable de puntero para que la comprobación de null (o la aplicación de un valor distinto de NULL) estuviera justificada. Por lo tanto, solo se emitirá una advertencia si se desreferencian los punteros y nunca se comprueba si son NULL.
  - La implementación actual solo controla los punteros sin formato (o sus alias) y no detecta punteros inteligentes, aunque GSL:: not_null se puede aplicar también a punteros inteligentes.
  - Una variable se marca como comprobada para la nulidad cuando se usa en los contextos siguientes:
  - como expresión de símbolo en una condición de bifurcación, por ejemplo, "If (p) {...}";
  - operaciones lógicas no bit a bit;
  - operaciones de comparación en las que un operando es una expresión constante que se evalúa como cero.
  - La regla no tiene seguimiento de flujo de entrada completo y puede producir resultados incorrectos en los casos en los que se usan comprobaciones indirectas (por ejemplo, cuando la variable intermedia contiene un valor NULL y se usa más adelante en la comparación).

## <a name="example"></a>Ejemplo

expectativa oculta

```cpp
using client_collection = gsl::span<client*>;
// ...
void keep_alive(const connection *connection)   // C26429
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];               // C26429
        client->send_heartbeat();
        // ...
    }
}
```

expectativa oculta: aclarado por GSL:: not_null

```cpp
using client_collection = gsl::span<gsl::not_null<client*>>;
// ...
void keep_alive(gsl::not_null<const connection*> connection)
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];
        client->send_heartbeat();
        // ...
    }
}
```
