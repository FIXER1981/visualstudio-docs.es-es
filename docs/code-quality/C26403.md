---
title: C26403
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26403
helpviewer_keywords:
- C26403
ms.assetid: 7e14868d-df86-4df3-98d3-71b1e80ba14e
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: af52b92127e91cfc10b4e36ed72299eff7289450
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/15/2020
ms.locfileid: "77261348"
---
# <a name="c26403-reset_or_delete_owner"></a>RESET_OR_DELETE_OWNER C26403

Los punteros de propietario son como punteros únicos: poseen un recurso exclusivamente y administran el lanzamiento del recurso, así como sus transferencias a otros propietarios. Esta comprobación valida que un puntero de propietario local mantiene correctamente su recurso a través de todas las rutas de acceso de ejecución de una función. Si el recurso no se transfirió a otro propietario, o no se libera explícitamente, el comprobador advierte y señala a la declaración de la variable de puntero.

Para obtener más información, consulte las [ C++ directrices básicas](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

## <a name="remarks"></a>Observaciones

- Actualmente, esta comprobación no proporciona la ruta de acceso exacta que no puede liberar el recurso. Este comportamiento se puede mejorar en versiones futuras. Puede ser difícil encontrar una ubicación exacta para una corrección. El mejor enfoque es intentar reemplazar los punteros sin formato en funciones complejas con punteros únicos para evitar riesgos.

- La comprobación puede descartar una función excesivamente complicada para no bloquear el análisis de código. Por lo general, la complejidad de las funciones debe mantenerse en un umbral razonable. Es posible que considere agregar una comprobación de complejidad local C++ al módulo Core Guidelines (Directrices básicas) si hay poca demanda para ello. Esta limitación se aplica a otras reglas que son sensibles al flujo de datos.

- La advertencia se puede activar en casos positivos falsos claramente en los que la memoria se elimina solo después de la comprobación de la nulación de un puntero. Este es el resultado de una limitación actual de la API de la herramienta, pero puede mejorarse en el futuro.

## <a name="example-1-missing-cleanup-during-error-handling"></a>Ejemplo 1: falta de limpieza durante el control de errores

```cpp
gsl::owner<int*> sequence = GetRandomSequence(); // C26403

try
{
    StartSimulation(sequence);
}
catch (const std::exception& e)
{
    if (KnownException(e))
        return; // Skipping the path which deletes the owner.

    ReportException(e);
}

delete [] sequence;
```
