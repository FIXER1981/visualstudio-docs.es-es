---
title: C26444
keywords: C26444
author: corob-msft
ms.author: corob
ms.date: 01/18/2017
ms.topic: reference
f1_keywords:
- C26444
helpviewer_keywords:
- C26444
dev_langs:
- C++
manager: markl
ms.openlocfilehash: f328f4ab49330b70f60ab84841326fcb367b5247
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/15/2020
ms.locfileid: "77264956"
---
# <a name="c26444-no_unnamed_raii_objects"></a>NO_UNNAMED_RAII_OBJECTS C26444

Evite objetos sin nombre con construcción y destrucción personalizadas.

## <a name="c-core-guidelines"></a>C++Directrices básicas

[ES. 84: no (intentar) declarar una variable local sin nombre](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-noname)

Los objetos sin nombre (es decir, temporales) con un comportamiento no trivial pueden apuntar a (a) código ineficaz que asigna e inmediatamente libera recursos o (b) al código que omite involuntariamente los datos no primitivos. En ocasiones, también puede indicar una declaración erróneamente incorrecta.

## <a name="notes"></a>Notas

- Esta regla detecta los tipos con destructores no eliminados. Tenga en cuenta que los destructores pueden ser generados por el compilador.
- La advertencia puede marcar código que no es generado por el compilador y que invoca un constructor no predeterminado de un tipo RAII o una función que devuelve un objeto de este tipo. Esta advertencia ayuda a detectar los resultados de llamadas omitidos además de las declaraciones equivocadas.
- La lógica omite objetos temporales si se usa en expresiones de nivel superior. Un ejemplo es objetos temporales que se pasan como argumentos o se usan para invocar una función.
- La implementación de la biblioteca estándar puede tener versiones diferentes de la lógica de destrucción para algunos tipos (por ejemplo, contenedores). Esto puede producir advertencias ruidosos en las compilaciones de depuración porque es un método personalizado para omitir los iteradores devueltos por llamadas como [STD:: Vector:: Insert](/cpp/standard-library/vector-class#insert). Aunque dichas advertencias no son procesables en la mayoría de los casos, son legítimas para señalar el lugar en el que se realiza algún trabajo no obvio en objetos temporales.

## <a name="example-ignored-call-result"></a>Ejemplo: resultado de la llamada omitido

```cpp
std::string ToTraceMessage(State &state);
void SaveState(State &state)
{
    // ...
    ToTraceMessage(state); // C26444, should we do something with the result of this call?
}

Example: Ignored call result - fixed.
std::cerr << ToTraceMessage(state);

Example: Unexpected lifetime.
void SplitCache()
{
    gsl::finally([] { RestoreCache(); }); // C26444, RestoreCache is invoked immediately!
    //...
}

Example: Unexpected lifetime - fixed.
const auto _ = gsl::finally([] { RestoreCache(); });
```

## <a name="see-also"></a>Consulte también

[ES. 84: no (intentar) declarar una variable local sin nombre](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)
