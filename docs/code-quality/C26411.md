---
title: C26411
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: f5b32327ad74d89b5351cbdaaa4efeebb7ec3379
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/23/2019
ms.locfileid: "62572085"
---
# <a name="c26411--noreftouniqueptr"></a>C26411  NO_REF_TO_UNIQUE_PTR

Pasar un puntero único por referencia supone que su recurso puede ser publicado o transfieren dentro de una función de destino. Si la función usa el parámetro solo para tener acceso al recurso, es seguro pasar un puntero sin formato o una referencia.

## <a name="remarks"></a>Comentarios

- Las limitaciones de la advertencia [C26410](C26410.md) son aplicables aquí también.

- La heurística para detectar "release" o "Restablecer" acceso a un puntero único es bastante sencilla: sólo detectamos las llamadas a los operadores de asignación y funciones con nombre "Restablecer" (mayúsculas y minúsculas). Obviamente, esta detección no cubre todos los casos posibles de las modificaciones de puntero inteligente (por ejemplo, STD o cualquier función no const especial en un puntero inteligente personalizado). Se espera que esta advertencia generará muchos falsos positivos en tipos personalizados, así como en algunos escenarios con punteros únicos estándares. Como se implementan las comprobaciones más centradas en punteros inteligentes, se mejorará la heurística.

- El hecho de que los punteros inteligentes suelen ser plantillas aporta una limitación interesante relacionada con el hecho de que el compilador no es necesario para procesar el código de plantilla de plantillas si no se utiliza. En algunas bases de código mínima que tienen un uso de interfaces de puntero inteligente limitado, el Comprobador de puede producir resultados inesperados debido a su incapacidad para identificar correctamente la semántica del tipo de plantilla (porque nunca se pueden usar algunas funciones importantes). En la norma `unique_pointer`, se mitiga esta limitación al reconocer el nombre del tipo. Esto se podría ampliar en el futuro para cubrir los punteros inteligentes más conocidos.

- Las expresiones lambda con una captura por referencia implícita pueden dar lugar a sorprendentes advertencias acerca de las referencias a punteros únicos. Actualmente se informa de todos los parámetros de referencia capturada en las expresiones lambda, independientemente de si se restablecen o no. La heurística que aquí se ampliará para correlacionar los campos de la expresión lambda con parámetros lambda en una versión futura.

## <a name="example-unnecessary-reference"></a>Ejemplo: Referencia innecesario

```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```