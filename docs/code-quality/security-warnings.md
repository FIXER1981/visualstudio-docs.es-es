---
title: Advertencias de seguridad
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9b5a03c9cb7ae7c5a5c81bd452dbb04d8db4c09d
ms.sourcegitcommit: ed17ca9ae5f92c229c4e46233bcfe0a49d29ec43
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/10/2020
ms.locfileid: "88052627"
---
# <a name="security-warnings"></a>Advertencias de seguridad

Las advertencias de seguridad son compatibles con las bibliotecas y aplicaciones más seguras. Estas advertencias ayudan a evitar los errores de seguridad en su programa. Si deshabilita cualquier advertencia de este tipo, se debe indicar el motivo claramente en el código además de informar al responsable de seguridad designado a ese proyecto de desarrollo.

## <a name="in-this-section"></a>En esta sección

|Regla|Descripción|
|----------|-----------------|
|[CA2100: Revisar consultas SQL para comprobar si tienen vulnerabilidades de seguridad](../code-quality/ca2100.md)|Un método establece la propiedad System.Data.IDbCommand.CommandText utilizando una cadena que se construye partiendo de un argumento de cadena para el método. Esta regla supone que el argumento de cadena contiene datos proporcionados por el usuario. Una cadena de comandos de SQL compilada a partir de datos proporcionados por el usuario es vulnerable a ataques de inserción de SQL.|
|[CA2102: Detectar las excepciones que no son CLSCompliant en los controladores generales](../code-quality/ca2102.md)|Un miembro de un ensamblado que no está marcado con el atributo RuntimeCompatibilityAttribute o está marcado con RuntimeCompatibility(WrapNonExceptionThrows = false) contiene un bloque catch que controla el objeto System.Exception y no contiene un bloque catch general inmediatamente después.|
|[CA2103: Revisar la seguridad imperativa](../code-quality/ca2103.md)|Un método utiliza la seguridad imperativa y podría estar creando el permiso utilizando la información de estado y los valores devueltos que pueden cambiar mientras la solicitud está activa. Utilice la seguridad declarativa siempre que sea posible.|
|[CA2104: No declarar tipos de referencias mutables de solo lectura](../code-quality/ca2104.md)|Un tipo visible externamente contiene un campo de sólo lectura visible externamente que es un tipo de referencia que se puede cambiar. Un tipo que mutable es un tipo cuyos datos de instancia se pueden modificar.|
|[CA2105: Los campos de matrices no deben ser de solo lectura](../code-quality/ca2105.md)|Cuando se aplica el modificador de solo lectura (ReadOnly en Visual Basic) a un campo que contiene una matriz, el campo no se puede modificar para hacer referencia a una matriz distinta. Sin embargo, se pueden cambiar los elementos de la matriz almacenados en un campo de sólo lectura.|
|[CA2106: Proteger las aserciones](../code-quality/ca2106.md)|Un método valida un permiso y no se realiza ninguna comprobación de seguridad en el llamador. Validar un permiso de seguridad sin realizar ninguna comprobación de seguridad puede dejar una debilidad de seguridad explotable en el código.|
|[CA2107: Revisar el uso de Deny y PermitOnly](../code-quality/ca2107.md)|Usar el método PermitOnly y CodeAccessPermission. deny las acciones de seguridad solo las deben usar los usuarios con conocimientos avanzados de seguridad de .NET. Debería realizarse una revisión de la seguridad del código que utiliza estas acciones de seguridad.|
|[CA2108: Revisar la seguridad declarativa en los tipos de valores](../code-quality/ca2108.md)|Un tipo de valor público o protegido está protegido por acceso a datos o peticiones de vínculos.|
|[CA2109: Revisar los controladores de eventos visibles](../code-quality/ca2109.md)|Se detectó un método de control de eventos público o protegido. No se deberían exponer los métodos de control de eventos a menos que sea absolutamente necesario.|
|[CA2111: Los punteros no deben estar visibles](../code-quality/ca2111.md)|Un puntero no es privado, interno ni de solo lectura. El código malintencionado puede cambiar el valor del puntero, permitiendo potencialmente el acceso a ubicaciones arbitrarias en memoria o provocando errores del sistema o de aplicación.|
|[CA2112: Los tipos seguros no deben exponer campos](../code-quality/ca2112.md)|Un tipo público o protegido contiene campos públicos y está protegido por peticiones de vínculos. Si el código tiene acceso a una instancia de tipo que está protegida por una solicitud de vínculo, el código no cumplirá la solicitud para obtener acceso a los campos del tipo.|
|[CA2114: La seguridad del método debe ser un supraconjunto del tipo](../code-quality/ca2114.md)|Un método no debe tener seguridad declarativa en el nivel de método y de tipo para la misma acción.|
|[CA2115: Llamar a Call GC.KeepAlive cuando se utilicen recursos nativos](../code-quality/ca2115.md)|Esta regla detecta errores que pueden haberse producido porque se finaliza un recurso no administrado mientras todavía se utiliza en código no administrado.|
|[CA2116: Los métodos APTCA deben llamar solo a métodos APTCA](../code-quality/ca2116.md)|Si está presente el atributo APTCA (AllowPartiallyTrustedCallers) en un ensamblado de plena confianza y el ensamblado ejecuta código en otro ensamblado que permite llamadores parcialmente confiables, se puede producir un ataque en el sistema de seguridad.|
|[CA2117: Los tipos APTCA solo amplían tipos base APTCA](../code-quality/ca2117.md)|Si está presente el atributo APTCA (AllowPartiallyTrustedCallers) en un ensamblado de plena confianza y un tipo del ensamblado se hereda de otro que permite llamadores parcialmente confiables, se puede producir un ataque de seguridad.|
|[CA2118: Revisar el uso de SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute cambia el comportamiento del sistema de seguridad predeterminado por miembros que ejecutan código no administrado que utiliza la interoperabilidad COM o la invocación de plataforma. Este atributo se utiliza principalmente para aumentar el rendimiento; sin embargo, las mejoras de rendimiento suponen riesgos de seguridad importantes.|
|[CA2119: Sellar los métodos que satisfacen las interfaces privadas](../code-quality/ca2119.md)|Un tipo público heredable proporciona una implementación de método reemplazable de una interfaz interna (de tipo "Friend" en Visual Basic). Para corregir una infracción de esta regla, impida que el método se invalide fuera del ensamblado.|
|[CA2120: Proteger los constructores de serializaciones](../code-quality/ca2120.md)|Este tipo tiene un constructor que toma un objeto System.Runtime.Serialization.SerializationInfo y un objeto System.Runtime.Serialization.StreamingContext (la firma del constructor de serialización). Una comprobación de seguridad no protege este constructor, pero protege uno o más constructores regulares del tipo.|
|[CA2121: Los constructores estáticos deben ser privados](../code-quality/ca2121.md)|El sistema llama al constructor estático antes de crear la primera instancia del tipo o antes de hacer referencia a cualquier miembro estático. Si un constructor estático no es privado, se puede llamar a través de un código distinto del sistema. En función de las operaciones que se realizan en el constructor, esto puede producir un comportamiento inesperado.|
|[CA2122: No exponer indirectamente métodos con peticiones de vínculos](../code-quality/ca2122.md)|Un miembro público o protegido tiene peticiones de vínculos y lo llama un miembro que no realiza ninguna comprobación de seguridad. Una solicitud de vínculo sólo comprueba los permisos del llamador inmediato.|
|[CA2123: Las peticiones de vínculos de invalidaciones deben ser idénticas a la base](../code-quality/ca2123.md)|Esta regla compara un método con su método base, que es una interfaz o un método virtual de otro tipo y, a continuación, compara las solicitudes de vínculos en cada uno. Si se infringe esta regla, un llamador malintencionado puede omitir la petición de vínculo tan solo con llamar al método no seguro.|
|[CA2124: Incluir cláusulas finally vulnerables en un bloque try externo](../code-quality/ca2124.md)|Un método público o protegido contiene un bloque try/finally. El bloque finally aparece para restablecer el estado de seguridad y no se incluye a sí mismo en un bloque finally.|
|[CA2126: Las peticiones de vínculos de tipos requieren peticiones de herencias](../code-quality/ca2126.md)|Un tipo público no sellado está protegido con una petición de vínculo y tiene un método reemplazable. Ni el tipo ni el método están protegidos con una petición de herencia.|
|[CA2130: Las constantes críticas para la seguridad deben ser transparentes](../code-quality/ca2130.md)|El cumplimiento de la transparencia no se exige para los valores constantes porque los compiladores alinean los valores constantes para que no se requiera ninguna búsqueda en tiempo de ejecución. Los campos constantes deberían ser transparentes en seguridad de modo que los revisores del código no supongan que el código transparente no puede tener acceso a la constante.|
|[CA2131: Los tipos críticos para la seguridad no pueden participar en la equivalencia de tipos](../code-quality/ca2131.md)|Un tipo participa en la equivalencia de tipos y el propio tipo, o un miembro o campo del tipo, se marca con el atributo SecurityCriticalAttribute. Esta regla se produce en todos los tipos críticos o en los tipos que contienen métodos o campos críticos que participan en la equivalencia de tipos. Cuando CLR detecta esta clase de tipo, no lo carga con TypeLoadException en tiempo de ejecución. Normalmente, esta regla solo se desencadena cuando los usuarios implementan la equivalencia de tipos manualmente en lugar de confiar en tlbimp y los compiladores para hacer la equivalencia de tipos.|
|[CA2132: Los constructores predeterminados deben ser al menos tan críticos para la seguridad como los constructores predeterminados de tipo base](../code-quality/ca2132.md)|El código de la aplicación Silverlight no puede usar los tipos y miembros con SecurityCriticalAttribute. El código de confianza puede utilizar solo tipos y miembros críticos para la seguridad en .NET Framework para la biblioteca de clases de Silverlight. Dado que una construcción pública o protegida en una clase derivada debe tener la misma transparencia, o mayor, que su clase base, una clase de una aplicación no puede derivar de una clase marcada como SecurityCritical.|
|[CA2133: Los delegados deben enlazarse a métodos con una transparencia coherente](../code-quality/ca2133.md)|Esta advertencia se desencadena en un método que enlaza un delegado que se marca con SecurityCriticalAttribute a un método que es transparente o que está marcado con SecuritySafeCriticalAttribute. La advertencia también desencadena un método que enlaza un delegado que es transparente o crítico para la seguridad a un método crítico.|
|[CA2134: Los métodos deben mantener una transparencia coherente al invalidar métodos base](../code-quality/ca2134.md)|Esta regla se desencadena cuando un método marcado con SecurityCriticalAttribute invalida un método que es transparente o está marcado con SecuritySafeCriticalAttribute. Esta regla también se desencadena cuando un método marcado con SecuritySafeCriticalAttribute invalida un método que es transparente o está marcado con SecurityCriticalAttribute. Se aplica la regla al invalidar un método virtual o implementar una interfaz.|
|[CA2135: Los ensamblados de nivel 2 no deben contener LinkDemands](../code-quality/ca2135.md)|LinkDemands está desusado en el conjunto de reglas de seguridad de nivel 2. En lugar de utilizar LinkDemands para exigir la seguridad en el momento de la compilación Just-In-Time (JIT), marque los métodos, tipos y campos con el atributo SecurityCriticalAttribute.|
|[CA2136: Los miembros no deben tener anotaciones de transparencia en conflicto](../code-quality/ca2136.md)|Los atributos de transparencia se aplican de los elementos de código de ámbito mayor a los elementos de ámbito menor. Los atributos de transparencia de los elementos de código con mayor ámbito tienen prioridad sobre los atributos de transparencia de los elementos de código incluidos en el primer elemento. Por ejemplo, una clase marcada con el atributo SecurityCriticalAttribute no puede contener un método marcado con el atributo SecuritySafeCriticalAttribute.|
|[CA2137: Los métodos transparentes deben contener solo IL que se pueda comprobar](../code-quality/ca2137.md)|Un método contiene código que no se puede comprobar o devuelve un tipo por referencia. Esta regla se desencadena en los intentos del código transparente en seguridad de ejecutar MSIL no comprobable (Lenguaje intermedio de Microsoft). Sin embargo, la regla no contiene un comprobador de IL completo y, en su lugar, utiliza la heurística para detectar la mayoría de las infracciones de comprobación MSIL.|
|[CA2138: Los métodos transparentes no deben llamar a métodos con el atributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Un método transparente en seguridad llama a un método marcado con el atributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: Los métodos transparentes no pueden usar el atributo HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Esta regla se desencadena en cualquier método que sea transparente e intenta controlar una excepción de daño de proceso mediante el atributo HandleProcessCorruptedStateExceptionsAttribute. Una excepción de daño de proceso es una clasificación de excepción de CLR versión 4,0 de excepciones como <xref:System.AccessViolationException> . El atributo HandleProcessCorruptedStateExceptionsAttribute solo lo pueden utilizar los métodos críticos para la seguridad, y se omitirá si se aplica a un método transparente.|
|[CA2140: El código transparente no debe hacer referencia a elementos críticos para la seguridad](../code-quality/ca2140.md)|Los métodos que se marcan con el atributo SecurityTransparentAttribute llaman a miembros no públicos marcados como SecurityCritical. Esta regla analiza todos los métodos y tipos de un ensamblado que tiene una mezcla de transparente y crítico, y marca las llamadas desde código transparente a código crítico no público que no están marcadas como SecurityTreatAsSafe.|
|[CA2141: Los métodos transparentes no deben satisfacer LinkDemands](../code-quality/ca2141.md)|Un método transparente en seguridad llama a un método de un ensamblado no marcado con APTCA (AllowPartiallyTrustedCallersAttribute) o bien satisface un LinkDemand para un tipo o un método.|
|[CA2142: El código transparente no debe protegerse con LinkDemands](../code-quality/ca2142.md)|Esta regla se desencadena en los métodos transparentes que requieren que las LinkDemand tengan acceso a ellos. El código transparente en seguridad no debería ser responsable de comprobar la seguridad de una operación y, por consiguiente, no debería exigir permisos.|
|[CA2143: Los métodos transparentes no deben usar peticiones de seguridad](../code-quality/ca2143.md)|El código transparente en seguridad no debería ser responsable de comprobar la seguridad de una operación y, por consiguiente, no debería exigir permisos. El código transparente en seguridad debería utilizar peticiones completas para tomar decisiones de seguridad y el código crítico para la seguridad no debió confiar en el código transparente al realizar la petición completa.|
|[CA2144: El código transparente no debe cargar ensamblados desde matrices de bytes](../code-quality/ca2144.md)|La revisión de seguridad del código transparente no es tan exhaustiva como la revisión de seguridad del código crítico, porque el código transparente no puede realizar acciones que afectan a la seguridad. Los ensamblados cargados desde una matriz de bytes podrían no distinguirse en el código transparente, y esa matriz de bytes podría contener código importante crítico para la seguridad, que no hace falta auditar.|
|[CA2145: Los métodos transparentes no deben ser representativos con el atributo SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Los métodos decorados con el atributo SuppressUnmanagedCodeSecurityAttribute tienen una LinkDemand implícita colocada en cualquier método que la llame. Esta LinkDemand requiere que el código de llamada sea crítico para la seguridad. Marcar el método que utiliza SuppressUnmanagedCodeSecurity con el atributo SecurityCriticalAttribute hace este requisito más obvio para los llamadores del método.|
|[CA2146: Los tipos deben ser al menos tan críticos para la seguridad como sus interfaces y tipos base](../code-quality/ca2146.md)|Esta regla se desencadena cuando un tipo derivado tiene un atributo de transparencia de seguridad que no es tan crítico como su tipo base o interfaz implementada. Solo los tipos críticos pueden derivar de los tipos base críticos o implementar interfaces críticas, y solo los tipos críticos o críticos para la seguridad pueden derivar de tipos base críticos para la seguridad o implementar interfaces críticas para la seguridad.|
|[CA2147: Los métodos transparentes no pueden usar aserciones de seguridad](../code-quality/ca2147.md)|Esta regla analiza todos los métodos y tipos de un ensamblado que es 100% transparente o tiene una mezcla de transparente y crítico, y marca cualquier uso declarativo o imperativo de Assert.|
|[CA2149: Los métodos transparentes no deben llamar a código nativo](../code-quality/ca2149.md)|Esta regla se desencadena en cualquier método transparente que llame directamente a código nativo, por ejemplo, a través de P/Invoke. Las infracciones de esta regla tienen como resultado una excepción MethodAccessException en el modelo de transparencia de nivel 2 y una demanda completa de UnmanagedCode en el modelo de transparencia de nivel 1.|
|[CA2151: Los campos con tipos críticos deben ser críticos para la seguridad](../code-quality/ca2151.md)|Para utilizar tipos críticos para la seguridad, el código que hace referencia al tipo debe ser crítico para la seguridad o crítico para la seguridad y disponible desde código transparente. Esto es así incluso si la referencia es indirecta. Por consiguiente, tener un campo transparente para la seguridad o crítico para la seguridad y disponible desde código transparente puede llevar a confusión, porque el código transparente todavía no podrá tener acceso al campo.|
|[CA2153: Evitar el control de excepciones de estado dañadas](../code-quality/ca2153.md)|Las[excepciones de estado dañado (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indican que la memoria está dañada en el proceso. Detectar estos problemas y evitar el bloqueo del proceso puede provocar vulnerabilidades de seguridad si un atacante puede colocar una vulnerabilidad de seguridad en la región de memoria dañada.|
|[CA2300: No usar el deserializador no seguro BinaryFormatter](../code-quality/ca2300.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2301: No llamar a BinaryFormatter.Deserialize sin establecer primero BinaryFormatter.Binder](../code-quality/ca2301.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2302: Asegurarse de que BinaryFormatter.Binder está establecido antes de llamar a BinaryFormatter.Deserialize](../code-quality/ca2302.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2305: No usar el deserializador no seguro LosFormatter](../code-quality/ca2305.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2310: No usar el deserializador no seguro NetDataContractSerializer](../code-quality/ca2310.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2311: No deserializar sin establecer primero NetDataContractSerializer.Binder](../code-quality/ca2311.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2312: Asegúrese de que se establece NetDataContractSerializer.Binder antes de deserializar](../code-quality/ca2312.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2315: No usar el deserializador no seguro ObjectStateFormatter](../code-quality/ca2315.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2321: No deserializar con JavaScriptSerializer mediante SimpleTypeResolver](../code-quality/ca2321.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2322: Asegúrese de que JavaScriptSerializer no se ha inicializado con SimpleTypeResolver antes de deserializar](../code-quality/ca2322.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2326: No usar valores TypeNameHandling que no sean None](../code-quality/ca2326.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2327: No usar valores JsonSerializerSettings no seguros](../code-quality/ca2327.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2328: Asegurarse de que los valores JsonSerializerSettings sean seguros](../code-quality/ca2328.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2329: No deserializar con JsonSerializer y una configuración no segura](../code-quality/ca2329.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2330: Asegurarse de que la configuración de JsonSerializer es segura al deserializar](../code-quality/ca2330.md)|Los deserializadores inseguros son vulnerables al deserializar datos que no son de confianza. Un atacante podría modificar los datos serializados para incluir tipos inesperados para insertar objetos con efectos secundarios malintencionados.|
|[CA2350: Asegurarse de que la entrada de DataTable.ReadXml() sea de confianza](ca2350.md)|Al deserializar un <xref:System.Data.DataTable> con una entrada que no es de confianza, un atacante puede crear una entrada malintencionada para realizar un ataque de denegación de servicio. Puede haber vulnerabilidades de ejecución de código remoto desconocidas.|
|[CA2351: Asegúrese de que la entrada de DataSet.ReadXml() sea de confianza](ca2351.md)|Al deserializar un <xref:System.Data.DataSet> con una entrada que no es de confianza, un atacante puede crear una entrada malintencionada para realizar un ataque de denegación de servicio. Puede haber vulnerabilidades de ejecución de código remoto desconocidas.|
|[CA2352: Un objeto DataSet o DataTable no seguro en un tipo serializable puede ser vulnerable a ataques de ejecución de código remoto](ca2352.md)|Una clase o estructura marcada con <xref:System.SerializableAttribute> contiene un <xref:System.Data.DataSet> campo o una <xref:System.Data.DataTable> propiedad, y no tiene un <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: Objeto DataSet o DataTable no seguro en un tipo serializable](ca2353.md)|Una clase o estructura marcada con un atributo de serialización XML o un atributo de contrato de datos contiene una <xref:System.Data.DataSet> propiedad o un <xref:System.Data.DataTable> campo o.|
|[CA2354: Un objeto DataSet o DataTable no seguro en un gráfico de objetos deserializado puede ser vulnerable a ataques de ejecución de código remoto](ca2354.md)|La deserialización con un <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serializado y el gráfico de objetos del tipo convertido pueden incluir <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2355: Objeto DataSet o DataTable no seguro en un gráfico de objetos deserializado](ca2355.md)|Deserializar cuando el gráfico de objetos del tipo especificado o convertido puede incluir <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2356: DataSet no seguro o DataTable en el gráfico de objetos deserializados Web](ca2356.md)|Un método con <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> o <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> tiene un parámetro que puede hacer referencia a un <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2361: Asegúrese de que la clase generada automáticamente que contiene DataSet. ReadXml () no se utiliza con datos que no son de confianza](ca2361.md)|Al deserializar un <xref:System.Data.DataSet> con una entrada que no es de confianza, un atacante puede crear una entrada malintencionada para realizar un ataque de denegación de servicio. Puede haber vulnerabilidades de ejecución de código remoto desconocidas.|
|[CA2362: el conjunto de seguridad no seguro o DataTable en el tipo serializable generado automáticamente puede ser vulnerable a ataques de ejecución remota de código.](ca2362.md)|Al deserializar la entrada que no es de confianza con <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> y el gráfico de objetos deserializados contiene <xref:System.Data.DataSet> o <xref:System.Data.DataTable> , un atacante puede crear una carga malintencionada para realizar un ataque de ejecución de código remoto.|
|[CA3001: Revisión de código en busca de vulnerabilidades de inyección de SQL](../code-quality/ca3001.md)|Al trabajar con comandos SQL y de entrada que no son de confianza, tenga en cuentan los ataques por inyección de SQL. Un ataque por inyección de SQL puede ejecutar comandos SQL malintencionados, poniendo en peligro la seguridad y la integridad de la aplicación.|
|[CA3002: Revisión de código en busca de vulnerabilidades de XSS](../code-quality/ca3002.md)|Al trabajar con una entrada que no es de confianza de las solicitudes Web, tenga en cuentan los ataques de scripting entre sitios (XSS). Un ataque XSS inyecta entradas que no son de confianza en salidas HTML sin procesar, lo que permite al atacante ejecutar scripts malintencionados o modificar contenido de forma malintencionada en la Página Web.|
|[CA3003: Revisión de código en busca de vulnerabilidades de inyección de rutas de acceso a archivos](../code-quality/ca3003.md)|Al trabajar con una entrada que no es de confianza de las solicitudes Web, tenga en cuentan el uso de entradas controladas por el usuario al especificar las rutas de acceso a los archivos.|
|[CA3004: Revisión de código en busca de vulnerabilidades de divulgación de información](../code-quality/ca3004.md)|Al revelar la información de la excepción, se ofrece a los atacantes información sobre el funcionamiento interno de la aplicación, lo que puede ayudar a los atacantes a encontrar otras vulnerabilidades que se puedan aprovechar.|
|[CA3006: Revisión de código en busca de vulnerabilidades de inyección de comandos de procesos](../code-quality/ca3006.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de comandos. Un ataque por inyección de comandos puede ejecutar comandos malintencionados en el sistema operativo subyacente, poniendo en peligro la seguridad y la integridad del servidor.|
|[CA3007: Revisión de código en busca de vulnerabilidades de redireccionamiento abierto](../code-quality/ca3007.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan las vulnerabilidades de redireccionamiento abierto. Un atacante puede aprovechar una vulnerabilidad de redirección abierta para usar el sitio web con el fin de dar la apariencia de una dirección URL legítima, pero redirigir a un visitante que no sospecha a un phishing u otra página web malintencionada.|
|[CA3008: Revisión de código en busca de vulnerabilidades de inyección de XPath](../code-quality/ca3008.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XPath. La construcción de consultas XPath mediante la entrada que no es de confianza puede permitir a un atacante manipular de forma malintencionada la consulta para devolver un resultado no deseado y, posiblemente, divulgar el contenido del XML consultado.|
|[CA3009: Revisión de código en busca de vulnerabilidades de inyección de XML](../code-quality/ca3009.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XML.|
|[CA3010: Revisión de código en busca de vulnerabilidades de inyección de XAML](../code-quality/ca3010.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de XAML. XAML es un lenguaje de marcado que representa directamente la creación de instancias y la ejecución de objetos. Esto significa que los elementos creados en XAML pueden interactuar con los recursos del sistema (por ejemplo, el acceso a la red y la e/s del sistema de archivos).|
|[CA3011: Revisión de código en busca de vulnerabilidades de inyección de DLL](../code-quality/ca3011.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan la carga de código que no es de confianza. Si la aplicación web carga código que no es de confianza, es posible que un atacante pueda insertar archivos dll malintencionados en el proceso y ejecutar código malintencionado.|
|[CA3012: Revisión de código en busca de vulnerabilidades de inyección de expresiones regulares](../code-quality/ca3012.md)|Al trabajar con una entrada que no es de confianza, tenga en cuentan los ataques por inyección de Regex. Un atacante puede usar la inyección de Regex para modificar de forma malintencionada una expresión regular, para hacer que el regex coincida con los resultados imprevistos o para hacer que la expresión regular consuma una CPU excesiva, lo que produce un ataque de denegación de servicio.|
|[CA3061: No agregar esquema por dirección URL](../code-quality/ca3061.md)|No use la sobrecarga no segura del método Add porque puede provocar referencias externas peligrosas.|
|[CA3075: Procesamiento no seguro de DTD](../code-quality/ca3075.md)|Si usa instancias de DTDProcessing inseguras o hace referencia a orígenes de entidades externas, el analizador podría aceptar entradas que no sean de confianza y revelar información confidencial a atacantes.|
|[CA3076: Ejecución del script XSLT no segura](../code-quality/ca3076.md)|Si ejecuta transformaciones del lenguaje de hojas de estilo extensible (XSLT) en aplicaciones .NET de forma no segura, el procesador puede resolver referencias de URI que no son de confianza y que podrían revelar información confidencial a atacantes, lo que provoca ataques de denegación de servicio y entre sitios.|
|[CA3077: Procesamiento no seguro en el diseño de una API, documento XML y lector de texto XML](../code-quality/ca3077.md)|Al diseñar una API derivada de XMLDocument y XMLTextReader, tenga en cuenta la propiedad DtdProcessing. El uso de instancias de DTDProcessing inseguras al hacer referencia a orígenes de entidades externas o resolverlos, o la definición de valores inseguros en el lenguaje XML puede provocar la divulgación de información.|
|[CA3147: Marcar los controladores de verbo con ValidateAntiForgeryToken](../code-quality/ca3147.md)|Al diseñar un controlador ASP.NET MVC, tenga en cuentan los ataques de falsificación de solicitudes entre sitios. Un ataque de falsificación de solicitudes entre sitios puede enviar solicitudes malintencionadas de un usuario autenticado a su controlador ASP.NET MVC.|
|[Las declaraciones de CA5122: P/Invoke no deben ser críticas para la seguridad](../code-quality/ca5122.md)|Los métodos se marcan como SecuritySafeCritical cuando realizan una operación que afecta a la seguridad pero también son seguros para su uso en código transparente. El código transparente nunca puede llamar a código nativo a través de P/Invoke. Por consiguiente, aunque se marque P/Invoke como crítico para la seguridad y disponible desde código transparente no permitirá que se llame desde código transparente llamarlo, y es erróneo para los análisis de seguridad.|
|[CA5359: No deshabilitar la validación de certificado](../code-quality/ca5359.md)|Un certificado puede ayudar a autenticar la identidad del servidor. Los clientes deben validar el certificado de servidor para asegurarse de que las solicitudes se envían al servidor previsto. Si ServerCertificateValidationCallback (siempre devuelve `true` , cualquier certificado pasará la validación.|
|[CA5360: No llamar a métodos peligrosos durante la deserialización](../code-quality/ca5360.md)|La deserialización no segura es una vulnerabilidad que se produce cuando los datos que no son de confianza se usan para abusar la lógica de una aplicación, provocar un ataque de denegación de servicio (DoS) o incluso ejecutar código arbitrario cuando se deserializa. A menudo, es posible que los usuarios malintencionados abusan estas características de deserialización cuando la aplicación está deserializando datos que no son de confianza y están bajo su control. En concreto, invoque métodos peligrosos en el proceso de deserialización. Los ataques de deserialización inseguros que se han realizado correctamente podrían permitir que un atacante lleve a cabo ataques como ataques de DoS, omisiones de autenticación y ejecución remota de código.|
|[CA5361: No deshabilitar el uso de cifrado seguro de SChannel](../code-quality/ca5361.md)|Establecer `Switch.System.Net.DontEnableSchUseStrongCrypto` para `true` debilita la criptografía usada en las conexiones de seguridad de la capa de transporte (TLS) salientes. La criptografía más débil puede poner en peligro la confidencialidad de la comunicación entre la aplicación y el servidor, lo que facilita a los atacantes la interceptación de información confidencial.|
|[CA5362: Ciclo de referencia potencial en gráfico de objetos deserializados](../code-quality/ca5362.md)|Si se deserializan los datos que no son de confianza, el procesamiento de código del gráfico de objetos deserializados debe controlar los ciclos de referencia sin entrar en bucles infinitos. Esto incluye el código que forma parte de una devolución de llamada de deserialización y el código que procesa el gráfico de objetos una vez completada la deserialización. De lo contrario, un atacante podría realizar un ataque por denegación de servicio con datos malintencionados que contuvieran un ciclo de referencia.|
|[CA5363: No deshabilitar la validación de solicitudes](../code-quality/ca5363.md)|La validación de solicitudes es una característica de ASP.NET que examina las solicitudes HTTP y determina si contienen contenido potencialmente peligroso que puede conducir a ataques de inyección, incluido el scripting entre sitios.|
|[CA5364: No usar protocolos de seguridad en desuso](../code-quality/ca5364.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo anteriores de TLS son menos seguras que las de TLS 1,2 y TLS 1,3 y es más probable que tengan nuevas vulnerabilidades. Evite las versiones anteriores del protocolo para minimizar el riesgo.|
|[CA5365: No deshabilitar la comprobación de encabezados HTTP](../code-quality/ca5365.md)|La comprobación de encabezados HTTP permite codificar el retorno de carro y los caracteres de nueva línea, \r y \n, que se encuentran en los encabezados de respuesta. Esta codificación puede ayudar a evitar ataques de inyección que aprovechan una aplicación que repite datos que no son de confianza contenidos en el encabezado.|
|[CA5366: Utilizar XmlReader para el XML de lectura de DataSet](../code-quality/ca5366.md)|El uso de <xref:System.Data.DataSet> para leer XML con datos que no son de confianza puede cargar referencias externas peligrosas, que se deben restringir mediante un <xref:System.Xml.XmlReader> con un solucionador seguro o con el procesamiento de DTD deshabilitado.|
|[CA5367: No serializar los tipos con campos de puntero](../code-quality/ca5367.md)|Esta regla comprueba si hay una clase serializable con una propiedad o un campo de puntero. Los miembros que no se pueden serializar pueden ser un puntero, como los miembros estáticos o los campos marcados con <xref:System.NonSerializedAttribute> .|
|[CA5368: Establecer ViewStateUserKey para clases derivadas de página](../code-quality/ca5368.md)|El establecimiento de la <xref:System.Web.UI.Page.ViewStateUserKey> propiedad puede ayudarle a evitar ataques en la aplicación al permitirle asignar un identificador a la variable de estado de vista de usuarios individuales para que los atacantes no puedan usar la variable para generar un ataque. De lo contrario, habrá vulnerabilidades en la falsificación de solicitudes entre sitios.|
|[CA5369: Usar XmlReader para deserializar](../code-quality/ca5369.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas, que se deben restringir mediante un XmlReader con un solucionador seguro o con el procesamiento de esquemas en línea XML y DTD deshabilitado.|
|[CA5370: Usar XmlReader para validar el lector](../code-quality/ca5370.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas. Esta carga peligrosa se puede restringir mediante el uso de un XmlReader con un solucionador seguro o con el procesamiento de esquemas en línea de DTD y XML deshabilitado.|
|[CA5371: Usar XmlReader para leer el esquema](../code-quality/ca5371.md)|El procesamiento de DTD y esquemas XML que no son de confianza puede habilitar la carga de referencias externas peligrosas. El uso de un XmlReader con un solucionador seguro o con DTD y el procesamiento de esquemas en línea XML deshabilitado restringe esto.|
|[CA5372: Usar XmlReader para XPathDocument](../code-quality/ca5372.md)|El procesamiento de XML a partir de datos que no son de confianza puede cargar referencias externas peligrosas, que se pueden restringir mediante un XmlReader con un solucionador seguro o con el procesamiento de DTD deshabilitado.|
|[CA5373: No usar la función de derivación de clave obsoleta](../code-quality/ca5373.md)|Esta regla detecta la invocación de métodos de derivación de claves débiles <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> y `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>usó un algoritmo débil del PBKDF1.|
|[CA5374: No utilizar XslTransform](../code-quality/ca5374.md)|Esta regla comprueba si <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> se crean instancias en el código. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType>está ahora obsoleto y no debe usarse.|
|[CA5375: No usar la firma de acceso compartido de la cuenta](../code-quality/ca5375.md)|Una SAS de cuenta puede delegar el acceso a operaciones de lectura, escritura y eliminación en contenedores de blobs, tablas, colas y recursos compartidos de archivos que no se permiten con una SAS de servicio. Sin embargo, no es compatible con las directivas de nivel de contenedor y tiene menos flexibilidad y control sobre los permisos que se conceden. Una vez que los usuarios malintencionados la obtienen, la cuenta de almacenamiento se verá comprometida fácilmente.|
|[CA5376: Usar HttpsOnly con SharedAccessProtocol](../code-quality/ca5376.md)|SAS es información confidencial que no se puede transportar en texto sin formato en HTTP.|
|[CA5377: Usar una directiva de acceso de nivel de contenedor](../code-quality/ca5377.md)|Una directiva de acceso de nivel de contenedor se puede modificar o revocar en cualquier momento. Proporciona mayor flexibilidad y control sobre los permisos que se conceden.|
|[CA5378: No deshabilitar ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Establecer `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` en `true` limita las conexiones de seguridad de la capa de transporte (TLS) de Windows Communication Framework (WCF) al uso de TLS 1,0. Esa versión de TLS quedará en desuso.|
|[CA5379: No usar el algoritmo de función de derivación de claves débiles](../code-quality/ca5379.md)|De <xref:System.Security.Cryptography.Rfc2898DeriveBytes> forma predeterminada, la clase usa el <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algoritmo. Debe especificar el algoritmo hash que se utilizará en algunas sobrecargas del constructor con <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> o superior. Tenga en cuenta <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> que la propiedad solo tiene un `get` descriptor de acceso y no tiene un `overriden` modificador.|
|[CA5380: No agregar certificados al almacén raíz](../code-quality/ca5380.md)|Esta regla detecta código que agrega un certificado al almacén de certificados de entidades de certificación raíz de confianza. De forma predeterminada, el almacén de certificados de entidades de certificación raíz de confianza se configura con un conjunto de entidades de certificación públicas que cumplen los requisitos del programa de certificados raíz de Microsoft.|
|[CA5381: Asegurar que no se agregan certificados al almacén raíz](../code-quality/ca5381.md)|Esta regla detecta código que puede Agregar un certificado al almacén de certificados de entidades de certificación raíz de confianza. De forma predeterminada, el almacén de certificados de entidades de certificación raíz de confianza se configura con un conjunto de entidades de certificación (CA) públicas que cumplen los requisitos del programa de certificados raíz de Microsoft.|
|[CA5382: Usar cookies seguras en ASP.NET Core](../code-quality/ca5382.md)|Las aplicaciones disponibles a través de HTTPS deben usar cookies seguras, que indican al explorador que la cookie solo se debe transmitir mediante seguridad de la capa de transporte (TLS).|
|[CA5383: Asegurarse de usar cookies seguras en ASP.NET Core](../code-quality/ca5383.md)|Las aplicaciones disponibles a través de HTTPS deben usar cookies seguras, que indican al explorador que la cookie solo se debe transmitir mediante seguridad de la capa de transporte (TLS).|
|[CA5384: No usar el algoritmo de firma digital (DSA)](../code-quality/ca5384.md)|DSA es un algoritmo de cifrado asimétrico débil.|
|[CA5385: Usar un algoritmo de Rivest-Shamir-Adleman (RSA) con un tamaño de clave suficiente](../code-quality/ca5385.md)|Una clave RSA de menos de 2048 bits es más vulnerable a los ataques por fuerza bruta.|
|[CA5386: Evitar codificar el valor SecurityProtocolType de forma rígida](../code-quality/ca5386.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo TLS 1,0 y TLS 1,1 están desusadas, mientras que TLS 1,2 y TLS 1,3 están actualizados. En el futuro, TLS 1,2 y TLS 1,3 pueden estar en desuso. Para asegurarse de que la aplicación sigue siendo segura, evite codificar una versión del protocolo y tenga como destino al menos .NET Framework v 4.7.1.|
|[CA5387: No usar una función de derivación de claves débiles con un recuento de iteraciones insuficiente](../code-quality/ca5387.md)|Esta regla comprueba si se generó una clave criptográfica <xref:System.Security.Cryptography.Rfc2898DeriveBytes> con un recuento de iteraciones inferior a 100.000. Un recuento de iteraciones mayor puede ayudar a mitigar los ataques de diccionario que intentan adivinar la clave criptográfica generada.|
|[CA5388: Garantizar un recuento de iteraciones suficiente al usar una función de derivación de claves débiles](../code-quality/ca5388.md)|Esta regla comprueba si se generó una clave criptográfica <xref:System.Security.Cryptography.Rfc2898DeriveBytes> con un recuento de iteraciones que puede ser inferior a 100.000. Un recuento de iteraciones mayor puede ayudar a mitigar los ataques de diccionario que intentan adivinar la clave criptográfica generada.|
|[CA5389: No agregar la ruta de acceso del elemento de archivo a la ruta de acceso del sistema de archivos de destino](../code-quality/ca5389.md)|La ruta de acceso de archivo puede ser relativa y puede dar lugar a un acceso al sistema de archivos fuera de la ruta de destino del sistema de archivos esperada, lo que provoca cambios de configuración malintencionados y la ejecución remota de código mediante la técnica de establecer y esperar.|
|[CA5390: No codificar la clave de cifrado de forma rígida](../code-quality/ca5390.md)|Para que un algoritmo simétrico se realice correctamente, solo el remitente y el receptor deben conocer la clave secreta. Cuando una clave está codificada de forma rígida, se detecta fácilmente. Incluso con los archivos binarios compilados, es fácil que los usuarios malintencionados lo extraigan. Una vez que la clave privada se ve comprometida, el texto cifrado se puede descifrar directamente y ya no está protegido.|
|[CA5391: Usar tokens antifalsificación en los controladores de ASP.NET Core MVC](../code-quality/ca5391.md)|Controlar una `POST` `PUT` solicitud,, `PATCH` o `DELETE` sin validar un token antifalsificación puede ser vulnerable a los ataques de falsificación de solicitudes entre sitios. Un ataque de falsificación de solicitudes entre sitios puede enviar solicitudes malintencionadas de un usuario autenticado a un controlador de MVC de ASP.NET Core.|
|[CA5392: Usar el atributo DefaultDllImportSearchPaths para P/Invoke](../code-quality/ca5392.md)|De forma predeterminada, las funciones P/Invoke <xref:System.Runtime.InteropServices.DllImportAttribute> que usan sondeos incluyen un número de directorios, incluido el directorio de trabajo actual de la biblioteca que se va a cargar. Puede tratarse de un problema de seguridad para ciertas aplicaciones, lo que conduce a la secuestro de DLL.|
|[CA5393: No usar un valor de DllImportSearchPath no seguro](../code-quality/ca5393.md)|Podría haber un archivo DLL malintencionado en los directorios de búsqueda DLL predeterminados y los directorios de ensamblado. O, en función de dónde se ejecute la aplicación, podría haber un archivo DLL malintencionado en el directorio de la aplicación.|
|[CA5394: No usar aleatoriedad no segura](../code-quality/ca5394.md)|El uso de un generador de números pseudoaleatorios no seguros criptográficamente puede permitir que un atacante prediga qué valor de seguridad se generará.|
|[CA5395: Falta el atributo HttpVerb para los métodos de acción](../code-quality/ca5395.md)|Todos los métodos de acción que crean, modifican, eliminan o modifican de algún otro modo los datos deben protegerse con el atributo antifalsificación de los ataques de falsificación de solicitudes entre sitios. Realizar una operación GET debe ser una operación segura que no tenga efectos secundarios y no modifique los datos persistentes.|
|[CA5396: Establecer HttpOnly en true para HttpCookie](../code-quality/ca5396.md)|Como medida de defensa en profundidad, asegúrese de que las cookies HTTP confidenciales de seguridad estén marcadas como HttpOnly. Esto indica que los exploradores Web deben impedir que los scripts tengan acceso a las cookies. Los scripts malintencionados insertados son una forma habitual de robar cookies.|
|[CA5397: No usar valores SslProtocols en desuso](../code-quality/ca5397.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo anteriores de TLS son menos seguras que las de TLS 1,2 y TLS 1,3 y es más probable que tengan nuevas vulnerabilidades. Evite las versiones anteriores del protocolo para minimizar el riesgo.|
|[CA5398: Evitar valores SslProtocols codificados de forma rígida](../code-quality/ca5398.md)|La seguridad de la capa de transporte (TLS) protege la comunicación entre equipos, normalmente con el protocolo seguro de transferencia de hipertexto (HTTPS). Las versiones de protocolo TLS 1,0 y TLS 1,1 están desusadas, mientras que TLS 1,2 y TLS 1,3 están actualizados. En el futuro, TLS 1,2 y TLS 1,3 pueden estar en desuso. Para asegurarse de que la aplicación sigue siendo segura, evite codificar una versión del protocolo.|
|[CA5399: Deshabilitar definitivamente la comprobación de la lista de revocación de certificados HttpClient](../code-quality/ca5399.md)|Un certificado revocado ya no es de confianza. Podría ser utilizado por los atacantes para pasar algunos datos malintencionados o robar datos confidenciales en la comunicación HTTPS.|
|[CA5400: Garantizar que la comprobación de la lista de revocación de certificados HttpClient no está deshabilitada](../code-quality/ca5400.md)|Un certificado revocado ya no es de confianza. Podría ser utilizado por los atacantes para pasar algunos datos malintencionados o robar datos confidenciales en la comunicación HTTPS.|
|[CA5401: No usar CreateEncryptor con un vector de inicialización no predeterminado](../code-quality/ca5401.md)|El cifrado simétrico siempre debe usar un vector de inicialización no repetible para evitar ataques de diccionario.|
|[CA5402: Usar CreateEncryptor con el vector de inicialización predeterminado](../code-quality/ca5402.md)|El cifrado simétrico siempre debe usar un vector de inicialización no repetible para evitar ataques de diccionario.|
