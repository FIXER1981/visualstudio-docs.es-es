---
title: 'CA1021: Evitar parámetros out'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 579b04f26af972ac025b0bfc07bc8dc9eb636d12
ms.sourcegitcommit: 98421670ed0b8170aaa32d3d6f8681298f401a1d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/18/2020
ms.locfileid: "81638026"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021: Evitar parámetros out

|||
|-|-|
|TypeName|AvoidOutParameters|
|Identificador de comprobación|CA1021|
|Categoría|Microsoft.Design|
|Cambio importante|Problemático|

## <a name="cause"></a>Causa
Un método público o protegido en `out` un tipo público tiene un parámetro.

De forma predeterminada, esta regla solo examina los tipos visibles externamente, pero esto es [configurable.](#configurability)

## <a name="rule-description"></a>Descripción de la regla
Pasar tipos por `out` referencia `ref`(mediante o ) requiere experiencia con punteros, comprender cómo difieren los tipos de valor y los tipos de referencia y controlar métodos con varios valores devueltos. Además, `out` la `ref` diferencia entre y los parámetros no se entiende ampliamente.

Cuando se pasa un tipo de referencia "por referencia", el método tiene la intención de utilizar el parámetro para devolver una instancia diferente del objeto. Pasar un tipo de referencia por referencia también se conoce como usar un puntero doble, puntero a un puntero o doble direccionamiento indirecto. Mediante el uso de la convención de llamada predeterminada, que es pasar "por valor", un parámetro que toma un tipo de referencia ya recibe un puntero al objeto. El puntero, no el objeto al que apunta, se pasa por valor. Pasar por valor significa que el método no puede cambiar el puntero para que apunte a una nueva instancia del tipo de referencia. Sin embargo, puede cambiar el contenido del objeto al que apunta. Para la mayoría de las aplicaciones esto es suficiente y produce el comportamiento deseado.

Si un método debe devolver una instancia diferente, utilice el valor devuelto del método para lograr esto. Consulte <xref:System.String?displayProperty=fullName> la clase para una variedad de métodos que operan en cadenas y devuelven una nueva instancia de una cadena. Cuando se utiliza este modelo, el autor de la llamada debe decidir si se conserva el objeto original.

Aunque los valores devueltos son comunes y `out` muy `ref` utilizados, la correcta aplicación y los parámetros requieren habilidades intermedias de diseño y codificación. Los arquitectos de bibliotecas que diseñan para `out` un `ref` público general no deben esperar que los usuarios dominen el trabajo o los parámetros.

## <a name="how-to-fix-violations"></a>Cómo corregir infracciones
Para corregir una infracción de esta regla causada por un tipo de valor, haga que el método devuelva el objeto como su valor devuelto. Si el método debe devolver varios valores, vuelva a diseñarlo para devolver una única instancia de un objeto que contiene los valores.

Para corregir una infracción de esta regla causada por un tipo de referencia, asegúrese de que el comportamiento deseado es devolver una nueva instancia de la referencia. Si es así, el método debe usar su valor devuelto para hacer esto.

## <a name="when-to-suppress-warnings"></a>Cuándo suprimir las advertencias
Es seguro suprimir una advertencia de esta regla. Sin embargo, este diseño podría causar problemas de usabilidad.

## <a name="configurability"></a>Configuración

Si está ejecutando esta regla desde [analizadores FxCop](install-fxcop-analyzers.md) (y no con análisis heredados), puede configurar en qué partes del código base ejecutar esta regla, en función de su accesibilidad. Por ejemplo, para especificar que la regla se ejecute solo en la superficie de API no pública, agregue el siguiente par clave-valor a un archivo .editorconfig del proyecto:

```ini
dotnet_code_quality.ca1021.api_surface = private, internal
```

Puede configurar esta opción solo para esta regla, para todas las reglas o para todas las reglas de esta categoría (Diseño). Para obtener más información, consulte [Configurar analizadores FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Ejemplo
La biblioteca siguiente muestra dos implementaciones de una clase que genera respuestas a los comentarios de un usuario. La primera`BadRefAndOut`implementación ( ) obliga al usuario de la biblioteca a administrar tres valores devueltos. La segunda`RedesignedRefAndOut`implementación ( ) simplifica la experiencia del usuario`ReplyData`al devolver una instancia de una clase contenedora ( ) que administra los datos como una sola unidad.

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]

## <a name="example"></a>Ejemplo
La siguiente aplicación ilustra la experiencia del usuario. La llamada a la`UseTheSimplifiedClass` biblioteca rediseñada (método) es más sencilla y la información devuelta por el método se administra fácilmente. La salida de los dos métodos es idéntica.

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]

## <a name="example"></a>Ejemplo
En la siguiente biblioteca `ref` de ejemplo se muestra cómo se usan los parámetros para los tipos de referencia y se muestra una mejor manera de implementar esta funcionalidad.

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]

## <a name="example"></a>Ejemplo
La siguiente aplicación llama a cada método de la biblioteca para demostrar el comportamiento.

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]

Este ejemplo produce el siguiente resultado:

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="try-pattern-methods"></a>Probar métodos de patrón

### <a name="description"></a>Descripción
Los métodos que implementan el <xref:System.Int32.TryParse%2A?displayProperty=fullName>patrón **Try\<Something>,** como , no generan esta infracción. En el ejemplo siguiente se muestra una <xref:System.Int32.TryParse%2A?displayProperty=fullName> estructura (tipo de valor) que implementa el método.

### <a name="code"></a>Código
[!code-csharp[FxCop.Design.TryPattern#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_5.cs)]

## <a name="related-rules"></a>Reglas relacionadas
[CA1045: No pasar tipos por referencia](../code-quality/ca1045.md)
