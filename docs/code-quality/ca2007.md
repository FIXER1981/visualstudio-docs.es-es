---
title: 'CA2007: No esperar una tarea directamente'
ms.date: 03/08/2019
ms.topic: reference
f1_keywords:
- CA2007
- DoNotDirectlyAwaitATaskAnalyzer
helpviewer_keywords:
- CA2007
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
ms.openlocfilehash: 8c1372d157fd34066370d7737b657efcfa190c67
ms.sourcegitcommit: 577c905de52057a741e68c2ed168ea527813fda5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/15/2020
ms.locfileid: "88249784"
---
# <a name="ca2007-do-not-directly-await-a-task"></a>CA2007: No esperar una tarea directamente

|Elemento|Valor|
|-|-|
|Identificador de comprobación|CA2007|
|Categoría|Microsoft.Reliability|
|Cambio importante|Poco problemático|

## <a name="cause"></a>Causa

Un método asincrónico [espera](/dotnet/csharp/language-reference/keywords/await) <xref:System.Threading.Tasks.Task> directamente.

## <a name="rule-description"></a>Descripción de la regla

Cuando un método asincrónico espera <xref:System.Threading.Tasks.Task> directamente, la continuación se produce normalmente en el mismo subproceso que creó la tarea, dependiendo del contexto asincrónico. Este comportamiento puede ser costoso en términos de rendimiento y puede dar lugar a un interbloqueo en el subproceso de la interfaz de usuario. Considere <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> la posibilidad de llamar a para señalar su intención de continuación.

Esta regla se presentó con los [analizadores de FxCop](install-fxcop-analyzers.md) y no existe en el análisis de FxCop heredado.

## <a name="how-to-fix-violations"></a>Cómo corregir infracciones

Para corregir las infracciones, llame a <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> en el Await <xref:System.Threading.Tasks.Task> . Puede pasar `true` o `false` para el `continueOnCapturedContext` parámetro.

- Llamar a `ConfigureAwait(true)` en la tarea tiene el mismo comportamiento que no llamar explícitamente a <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> . Al llamar explícitamente a este método, está permitiendo a los lectores saber que desea realizar la continuación en el contexto de sincronización original.

- Llame a `ConfigureAwait(false)` en la tarea para programar continuaciones en el grupo de subprocesos, evitando así un interbloqueo en el subproceso de la interfaz de usuario. Pasar `false` es una buena opción para las bibliotecas independientes de la aplicación.

## <a name="when-to-suppress-warnings"></a>Cuándo suprimir advertencias

Esta advertencia está destinada a las bibliotecas, donde el código se puede ejecutar en entornos arbitrarios y donde el código no debe realizar suposiciones sobre el entorno o cómo el llamador del método puede invocar o esperar en él. Por lo general, es adecuado suprimir la advertencia por completo para los proyectos que representan código de aplicación en lugar de código de biblioteca. de hecho, la ejecución de este analizador en el código de la aplicación (por ejemplo, los controladores de eventos de clic de botón en un proyecto de WinForms o WPF) podría provocar que se realicen las acciones incorrectas.

Puede suprimir esta advertencia en cualquier situación en la que la continuación se deba programar de nuevo en el contexto original o en el lugar en el que no haya ningún contexto de ese tipo. Por ejemplo, al escribir código en un controlador de eventos de clic de botón en una aplicación WinForms o WPF, en general la continuación de una Await debe ejecutarse en el subproceso de la interfaz de usuario y, por lo tanto, es conveniente el comportamiento predeterminado de la programación de la continuación en el contexto de origen. Como otro ejemplo, al escribir el código en una aplicación ASP.NET Core, de forma predeterminada, no hay ningún <xref:System.Threading.SynchronizationContext> o <xref:System.Threading.Tasks.TaskScheduler> , por lo que no `ConfigureAwait` cambiaría realmente ningún comportamiento.

## <a name="example"></a>Ejemplo

El siguiente fragmento de código genera la ADVERTENCIA:

```csharp
public async Task Execute()
{
    Task task = null;
    await task;
}
```

Para corregir la infracción, llame a <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> en Await <xref:System.Threading.Tasks.Task> :

```csharp
public async Task Execute()
{
    Task task = null;
    await task.ConfigureAwait(false);
}
```

## <a name="configurability"></a>Configurabilidad

Puede configurar si desea excluir métodos asincrónicos que no devuelven un valor de esta regla. Para excluir estos tipos de métodos, agregue el siguiente par clave-valor a un archivo. editorconfig en el proyecto:

```ini
# Package version 2.9.0 and later
dotnet_code_quality.CA2007.exclude_async_void_methods = true

# Package version 2.6.3 and earlier
dotnet_code_quality.CA2007.skip_async_void_methods = true
```

También puede configurar los tipos de ensamblado de salida a los que aplicar esta regla. Por ejemplo, para aplicar esta regla solo al código que produce una aplicación de consola o una biblioteca vinculada dinámicamente (es decir, no una aplicación de interfaz de usuario), agregue el siguiente par clave-valor a un archivo. editorconfig en el proyecto:

```ini
dotnet_code_quality.CA2007.output_kind = ConsoleApplication, DynamicallyLinkedLibrary
```

Para obtener más información, vea [configurar analizadores de FxCop](configure-fxcop-analyzers.md).

## <a name="see-also"></a>Vea también

- [Preguntas más frecuentes sobre ConfigureAwait](https://devblogs.microsoft.com/dotnet/configureawait-faq/)
- [¿Debo esperar una tarea con ConfigureAwait (false)?](https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md#should-i-await-a-task-with-configureawaitfalse)
- [Instalar analizadores de FxCop en Visual Studio](install-fxcop-analyzers.md)
