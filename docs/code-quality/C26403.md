---
title: C26403
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26403
helpviewer_keywords:
- C26403
ms.assetid: 7e14868d-df86-4df3-98d3-71b1e80ba14e
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: aded774f0d7a871845377d6b0963db80f399170d
ms.sourcegitcommit: 87d7123c09812534b7b08743de4d11d6433eaa13
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/01/2019
ms.locfileid: "57221611"
---
# <a name="c26403-resetordeleteowner"></a>C26403 RESET_OR_DELETE_OWNER

Punteros de propietario son similares a los punteros únicos: que posee un recurso exclusivamente y administrar la liberación de los recursos, así como sus transferencias a otros propietarios. Esta comprobación se valida que un puntero de propietario local mantiene correctamente sus recursos a través de todas las rutas de ejecución en una función. Si el recurso no se ha transferido a otro propietario o no era explícitamente la versión, el corrector advierte y señala a la declaración de la variable de puntero.

Para obtener más información, consulte el [directrices centrales de C++](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

## <a name="remarks"></a>Comentarios

- Actualmente esta comprobación no le ofrece la ruta de acceso exacta que se produce un error al liberar el recurso. Este comportamiento se puede mejorar en futuras versiones. Puede ser difícil encontrar la ubicación exacta de una corrección. El mejor enfoque consiste en intentar reemplazar sin formato punteros de funciones complejas con punteros únicos a fin de evitar riesgos.

- La verificación puede descartar una función demasiado complicada para no bloquear el análisis de código. Por lo general, la complejidad de las funciones debe mantenerse bajo algún límite máximo razonable. Podríamos agregar una comprobación de complejidad local al módulo C++ principales directrices si hay demanda clara para él. Esta limitación es aplicable a otras reglas que son sensibles al flujo de datos.

- La advertencia se puede desencadenar en casos positivos falsos claramente donde se elimina la memoria sólo después de la comprobación de nullness de un puntero. Esto es el resultado de una limitación de la API de la herramienta actual, pero puede mejorarse en el futuro.

## <a name="example-1-missing-cleanup-during-error-handling"></a>Ejemplo 1: Falta de limpieza durante el tratamiento de errores

```cpp
gsl::owner<int*> sequence = GetRandomSequence(); // C26403

try
{
    StartSimulation(sequence);
}
catch (const std::exception& e)
{
    if (KnownException(e))
        return; // Skipping the path which deletes the owner.

    ReportException(e);
}

delete [] sequence;
```
