---
title: C6211
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 1a6f490d8bc068a56b38bf800ea680c4ec796f2c
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/15/2020
ms.locfileid: "77268163"
---
# <a name="c6211"></a>C6211
ADVERTENCIA C6211: pérdida de memoria \<puntero > debido a una excepción. Considere la posibilidad de usar un bloque catch local para limpiar la memoria

 Esta advertencia indica que no se libera memoria asignada cuando se produce una excepción. La instrucción al final de la ruta de acceso podría producir una excepción. El analizador comprueba esta condición solo cuando se especifica la anotación SAL `_Analysis_mode_(_Analysis_local_leak_checks_)`. De forma predeterminada, esta anotación se especifica para el código del modo kernel de Windows (controlador). Para obtener más información sobre las anotaciones SAL, consulte [uso de anotaciones sal para reducir defectosC++ de C/Code](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).

## <a name="example"></a>Ejemplo
 El código siguiente genera esta advertencia porque se puede producir una excepción durante la segunda asignación y, por tanto, se pierde la primera asignación, o bien se puede iniciar una excepción en algún lugar del código representado por el comentario "`code ...`" y, por tanto, se pueden filtrar ambas asignaciones.

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>

_Analysis_mode_(_Analysis_local_leak_checks_)
void f( )
{
    char *p1 = new char[10];
    char *p2 = new char[10];

    // code ...

    delete[] p2;
    delete[] p1;
}
```

 Para usar las mismas funciones de asignación y corregir este problema, agregue un controlador de excepciones:

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <new>
#include <iostream>
using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f()
{
    char *p1 = nullptr;
    char *p2 = nullptr;

    try
    {
        p1 = new char[10];
        p2 = new char[10];

        // code ...

        delete [] p2;
        delete [] p1;
    }
    catch (const bad_alloc& ba)
    {
        cout << ba.what() << endl;
        delete [] p2;
        delete [] p1;
    }
    // code ...
}
```

 Para evitar todos estos tipos de fugas posibles, use los mecanismos proporcionados por la biblioteca de C++ plantillas estándar (STL). Entre ellas se incluyen [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)y [Vector](/cpp/standard-library/vector). Para obtener más información, vea [punteros inteligentes](/cpp/cpp/smart-pointers-modern-cpp) y [ C++ biblioteca estándar](/cpp/standard-library/cpp-standard-library-reference).

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <vector>
#include <memory>

using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f( )
{
    // use 10-element vectors in place of char[10]
    vector<char> v1;
    vector<char> v2;

    for (int i=0; i<10; ++i) {
        v1.push_back('a');
        v2.push_back('b');
    }
    // code ...

    // use unique_ptr if you still want char[10]
    unique_ptr<char[]> a1(new char[10]);
    unique_ptr<char[]> a2(new char[10]);

    // code ...

    // No need for delete; vector and unique_ptr
    // clean up when out of scope.
}
```

## <a name="see-also"></a>Vea también
 [Control de excepciones de C++](/cpp/cpp/cpp-exception-handling)
