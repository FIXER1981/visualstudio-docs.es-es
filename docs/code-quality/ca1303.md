---
title: 'CA1303: No pasar literales como parámetros localizados'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: e6b4fad16bc1c4b205ea09a39af8d38e08db848f
ms.sourcegitcommit: ade07bd1cf69b8b494d171ae648cfdd54f7800d3
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/21/2020
ms.locfileid: "81649154"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: No pasar literales como parámetros localizados

|||
|-|-|
|TypeName|DoNotPassLiteralsAsLocalizedParameters|
|Identificador de comprobación|CA1303|
|Categoría|Microsoft.Globalization|
|Cambio importante|Poco problemático|

## <a name="cause"></a>Causa

Un método pasa un literal de cadena como parámetro a un constructor o método de .NET y esa cadena debe ser localizable.

Esta advertencia se genera cuando se pasa una cadena literal como un valor a un parámetro o propiedad y uno o varios de los siguientes casos es true:

- El <xref:System.ComponentModel.LocalizableAttribute> atributo del parámetro o propiedad se establece en true.

- El nombre del parámetro de cadena que se pasa a un método Console.Write o Console.WriteLine es "value" o "format".

De forma predeterminada, esta regla analiza todo el código base, pero esto es [configurable.](#excluded-type-names-with-derived-types)

A partir de la versión 3.0.0 del paquete del analizador, la heurística de nomenclatura ya no se utiliza de forma predeterminada, pero esto es [configurable.](#use-naming-heuristic)

## <a name="rule-description"></a>Descripción de la regla

Los literales de cadena incrustados en el código fuente son difíciles de localizar.

## <a name="how-to-fix-violations"></a>Cómo corregir infracciones

Para corregir una infracción de esta regla, reemplace el literal <xref:System.Resources.ResourceManager> de cadena por una cadena recuperada a través de una instancia de la clase.

## <a name="when-to-suppress-warnings"></a>Cuándo suprimir las advertencias

Es seguro suprimir una advertencia de esta regla si la biblioteca de código no se localizará o si la cadena no se expone al usuario final o a un desarrollador que usa la biblioteca de código.

Los usuarios pueden eliminar el ruido con respecto a los métodos que no se deben pasar cadenas localizadas cambiando el nombre del parámetro o la propiedad, o marcando estos elementos como condicionales.

## <a name="configurability"></a>Configuración

Si está ejecutando esta regla desde [analizadores FxCop](install-fxcop-analyzers.md) (y no con análisis heredados), esta regla es configurable.

### <a name="excluded-type-names-with-derived-types"></a>Nombres de tipo excluidos con tipos derivados

Puede configurar qué tipos, incluidos sus tipos derivados, se excluirán del análisis. Por ejemplo, para especificar que la regla no `MyType` se debe ejecutar en ningún método dentro de los tipos denominados y sus tipos derivados, agregue el siguiente par clave-valor a un archivo .editorconfig del proyecto:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formatos de nombre de símbolo permitidos en el valor de la opción (separados por ''):

- Solo nombre de tipo (incluye todos los tipos con el nombre, independientemente del tipo o espacio de nombres que lo contiene)
- Nombres completos en el formato de [ID](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format) `T:` de documentación del símbolo, con un prefijo opcional.

Ejemplos:

| Valor de la opción | Resumen |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Coincide con todos los tipos denominados 'MyType' y todos sus tipos derivados en la compilación
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Coincide con todos los tipos denominados 'MyType1' o 'MyType2' y todos sus tipos derivados en la compilación
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Coincide con el tipo específico 'MyType' con el nombre completo dado y todos sus tipos derivados
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Coincide con tipos específicos 'MyType1' y 'MyType2' con los nombres completos respectivos y todos sus tipos derivados

Puede configurar esta opción solo para esta regla, para todas las reglas o para todas las reglas de esta categoría (Globalización). Para obtener más información, consulte [Configurar analizadores FxCop](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Usar nombres heurísticos

Puede configurar si el nombre de parámetros o propiedades que contiene "Texto", "Mensaje" o "Título" desencadenará esta regla.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a>Ejemplo

En el ejemplo siguiente se muestra un método que produce una excepción cuando cualquiera de sus dos argumentos está fuera del intervalo. Para el primer argumento, al constructor de excepción se le pasa una cadena literal, que infringe esta regla. Para el segundo argumento, el constructor se pasa <xref:System.Resources.ResourceManager>correctamente una cadena recuperada a través de un archivo .

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Consulte también

- [Recursos de aplicaciones de escritorio](/dotnet/framework/resources/index)
- [Solicitud de comunidad de cambio de comportamiento](https://github.com/dotnet/roslyn-analyzers/issues/2933)
