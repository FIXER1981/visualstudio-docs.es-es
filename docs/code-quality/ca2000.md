---
title: 'CA2000: Eliminar objetos antes de perder el ámbito'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615568"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Eliminar objetos antes de perder el ámbito

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|Identificador de comprobación|CA2000|
|Categoría|Microsoft.Reliability|
|Cambio importante|Poco problemático|

## <a name="cause"></a>Causa

Se crea un <xref:System.IDisposable> objeto local de un tipo, pero el objeto no se elimina antes de que todas las referencias al objeto estén fuera del ámbito.

De forma predeterminada, esta regla analiza todo el código base, pero esto es [configurable.](#configurability)

## <a name="rule-description"></a>Descripción de la regla

Si un objeto que se puede eliminar (método Dispose) no se elimina de forma explícita antes de que todas las referencias a él estén fuera de ámbito, el objeto se eliminará en algún momento indeterminado cuando el recolector de elementos no utilizados ejecute el finalizador del objeto. Puesto que podría producirse un evento excepcional que impida que se ejecute el finalizador del objeto, el objeto debe eliminarse de forma explícita.

### <a name="special-cases"></a>Casos especiales

La regla CA2000 no se activa para objetos locales de los siguientes tipos, incluso si el objeto no se elimina:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Pasar un objeto de uno de estos tipos a un constructor y, a continuación, asignarlo a un campo indica una transferencia de *propiedad de eliminación* al tipo recién construido. Es decir, el tipo recién construido es ahora responsable de la eliminación del objeto. Si el código pasa un objeto de uno de estos tipos a un constructor, no se produce ninguna infracción de la regla CA2000 incluso si el objeto no se elimina antes de que todas las referencias a él estén fuera del ámbito.

## <a name="how-to-fix-violations"></a>Cómo corregir infracciones

Para corregir una infracción de esta regla, llame a <xref:System.IDisposable.Dispose%2A> en el objeto antes de que todas las referencias a este estén fuera de ámbito.

Puede usar la[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) <xref:System.IDisposable> [ `using` instrucción](/dotnet/csharp/language-reference/keywords/using-statement) ( en Visual Basic) para ajustar los objetos que implementan . Los objetos que se ajustan de esta manera `using` se eliminan automáticamente al final del bloque. Sin embargo, las siguientes situaciones no `using` deben o no se deben manejar con una instrucción:

- Para devolver un objeto desechable, el `try/finally` objeto debe `using` construirse en un bloque fuera de un bloque.

- No inicialice los miembros de un `using` objeto desechable en el constructor de una instrucción.

- Cuando los constructores protegidos por un solo controlador de excepciones están anidados en la [parte de adquisición de una `using` instrucción,](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)un error en el constructor externo puede provocar que el objeto creado por el constructor anidado nunca se cierre. En el ejemplo siguiente, <xref:System.IO.StreamReader> un error en <xref:System.IO.FileStream> el constructor puede provocar que el objeto nunca se cierre. CA2000 marca una infracción de la regla en este caso.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Los objetos dinámicos deben utilizar un <xref:System.IDisposable> objeto de sombra para implementar el patrón de eliminación de objetos.

## <a name="when-to-suppress-warnings"></a>Cuándo suprimir las advertencias

No suprima una advertencia de esta regla a menos que:

- Ha llamado a un método en `Dispose`el objeto que llama a , como<xref:System.IO.Stream.Close%2A>
- El método que generó <xref:System.IDisposable> la advertencia devuelve un objeto que ajusta el objeto
- El método de asignación no tiene propiedad de eliminación; es decir, la responsabilidad de eliminar el objeto se transfiere a otro objeto o contenedor que se crea en el método y se devuelve al autor de la llamada

## <a name="configurability"></a>Configuración

Si está ejecutando esta regla desde [analizadores FxCop](install-fxcop-analyzers.md) (y no con análisis heredados), puede configurar el análisis para esta regla.

### <a name="excluded-symbol-names"></a>Nombres de símbolos excluidos

Puede configurar qué partes del código base se excluirán del análisis. Por ejemplo, para especificar que la regla no `MyType`se debe ejecutar en ningún código dentro de los tipos denominados , agregue el siguiente par clave-valor a un archivo .editorconfig del proyecto:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Formatos de nombre de símbolo permitidos en el valor de la opción (separados por ''):
  - Solo nombre de símbolo (incluye todos los símbolos con el nombre, independientemente del tipo o espacio de nombres que lo contiene)
  - Nombres completos en el formato de ID de [documentación](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)del símbolo. Cada nombre de símbolo requiere un prefijo de tipo de símbolo, como prefijo "M:" para métodos, prefijo "T:" para tipos, prefijo "N:" para espacios de nombres, etc.
  - `.ctor`para constructores `.cctor` y para constructores estáticos

Ejemplos:

| Valor de la opción | Resumen |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Coincide con todos los símbolos denominados 'MyType' en la compilación
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Coincide con todos los símbolos denominados 'MyType1' o 'MyType2' en la compilación
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Coincide con el método específico 'MyMethod' con una firma completa dada
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Coincide con los métodos específicos 'MyMethod1' y 'MyMethod2' con la firma completa respectiva

Puede configurar todas estas opciones solo para esta regla, para todas las reglas o para todas las reglas de esta categoría (Diseño). Para obtener más información, consulte [Configurar analizadores FxCop](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Reglas relacionadas

- [CA2213: Aplique Dispose a los campos a los que se pueda](../code-quality/ca2213.md)
- [CA2202: No aplicar Dispose a los objetos varias veces](../code-quality/ca2202.md)

## <a name="example"></a>Ejemplo

Si va a implementar un método que devuelve un objeto desechable, use un bloque try/finally sin un bloque catch para asegurarse de que el objeto está eliminado. Al usar un bloque try/finally, permite la generación de excepciones en el momento del error y se asegura de que se elimine el objeto.

En el método OpenPort1, se puede producir un error en la llamada para abrir el elemento SerialPort del objeto ISerializable o en la llamada a SomeMethod. En esta implementación se desencadena una advertencia CA2000.

En el método OpenPort2, dos objetos SerialPort se declaran y establecen en NULL:

- `tempPort`, que se usa para probar la correcta realización de las operaciones del método.

- `port`, que se utiliza para el valor devuelto del método.

`tempPort` se construye y abre en un bloque `try` y cualquier otro trabajo que sea necesario se realiza en el mismo bloque `try`. Al final del bloque `try`, el puerto abierto se asigna al objeto `port` que se devolverá y el objeto `tempPort` se establece en `null`.

El bloque `finally` comprueba el valor de `tempPort`. Si no es NULL, se ha producido un error en una operación del método y `tempPort` se cierra para garantizar la liberación de los recursos. El objeto Port devuelto contendrá el objeto SerialPort abierto si las operaciones del método se han realizado correctamente o será NULL si se produce un error en una operación.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Ejemplo

De forma predeterminada, el compilador de Visual Basic tiene todos los operadores aritméticos comprobar el desbordamiento. Por consiguiente, cualquier operación aritmética de Visual Basic puede producir una excepción de tipo <xref:System.OverflowException>. Esto podría dar lugar a infracciones inesperadas de reglas como CA2000. Por ejemplo, la siguiente función CreateReader1 producirá una infracción de CA2000 porque el compilador de Visual Basic emite una instrucción de comprobación de desbordamiento para la suma que podría producir una excepción que provocaría que StreamReader no se eliminase.

Para corregir este problema, puede deshabilitar la emisión de comprobaciones de desbordamiento mediante el compilador de Visual Basic en el proyecto o puede modificar el código como en la siguiente función CreateReader2.

Para deshabilitar la emisión de comprobaciones de desbordamiento, haga clic con el botón secundario en el nombre del proyecto en el Explorador de soluciones y, a continuación, haga clic en **Propiedades**. Haga clic en **Compilar**, haga clic en **Opciones avanzadas**de compilación y, a continuación, active **Quitar comprobaciones**de desbordamiento de enteros .

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Consulte también

- <xref:System.IDisposable>
- [Patrón de Dispose](/dotnet/standard/design-guidelines/dispose-pattern)
