---
title: 'CA1838: Evitar los parámetros StringBuilder para los elementos P/Invoke'
ms.date: 08/03/2020
ms.topic: reference
f1_keywords:
- AvoidStringBuilderPInvokeParameters
- CA1838
helpviewer_keywords:
- AvoidStringBuilderPInvokeParameters
- CA1838
author: elinor-fung
ms.author: elfung
manager: jeffschw
ms.workload:
- multiple
ms.openlocfilehash: a18ab1cb6c260908cbbe327e7ac8dfc516681fab
ms.sourcegitcommit: a18c7e9b367c2f92f6e54c3eaef442775d457667
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/15/2020
ms.locfileid: "90099002"
---
# <a name="ca1838-avoid-stringbuilder-parameters-for-pinvokes"></a>CA1838: evitar `StringBuilder` parámetros para P/Invoke

|Elemento|Valor|
|-|-|
|RuleId|CA1838|
|Category|Microsoft. performance|
|Cambio importante|Poco problemático|

## <a name="cause"></a>Causa

[P/Invoke](/dotnet/standard/native-interop/pinvoke) tiene un <xref:System.Text.StringBuilder> parámetro.

## <a name="rule-description"></a>Descripción de la regla

La serialización de `StringBuilder` siempre crea una copia de búfer nativa, lo que da lugar a varias asignaciones para una llamada P/Invoke. Para calcular las referencias de `StringBuilder` como un parámetro P/Invoke, el Runtime hará lo siguiente:
- Asignación de un búfer nativo
- Si es un `In` parámetro, copie el contenido de `StringBuilder` en el búfer nativo.
- Si es un `Out` parámetro, copie el búfer nativo en una matriz administrada recién asignada.

De forma predeterminada, `StringBuilder` es `In` y `Out` .

Esta regla está deshabilitada de forma predeterminada porque puede requerir el análisis de casos por caso de que la infracción sea de interés y de refactorización potencialmente no trivial para solucionar la infracción. Los usuarios pueden habilitar explícitamente esta regla configurando la [gravedad de las reglas del analizador](use-roslyn-analyzers.md#configure-severity-levels).

## <a name="how-to-fix-violations"></a>Cómo corregir infracciones

En general, la dirección de una infracción implica el retrabajo de P/Invoke y sus llamadores para utilizar un búfer en lugar de `StringBuilder` . Los detalles dependerán de los casos de uso de P/Invoke.

Este es un ejemplo para el escenario común de uso de `StringBuilder` como búfer de salida que va a rellenar la función nativa:

```csharp
// Violation
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern void Foo(StringBuilder sb, ref int length);

public void Bar()
{
    int BufferSize = ...
    StringBuilder sb = new StringBuilder(BufferSize);
    int len = sb.Capacity;
    Foo(sb, ref len);
    string result = sb.ToString();
}
```

En los casos de uso en los que el búfer es pequeño y el `unsafe` código es aceptable, se puede usar [stackalloc](/dotnet/csharp/language-reference/operators/stackalloc) para asignar el búfer en la pila:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern unsafe void Foo(char* buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    unsafe
    {
        char* buffer = stackalloc char[BufferSize];
        int len = BufferSize;
        Foo(buffer, ref len);
        string result = new string(buffer);
    }
}
```

En el caso de los búferes mayores, se puede asignar una nueva matriz como búfer:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern void Foo([Out] char[] buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    char[] buffer = new char[BufferSize];
    int len = buffer.Length;
    Foo(buffer, ref len);
    string result = new string(buffer);
}
```

Cuando a menudo se llama a P/Invoke para búferes de mayor tamaño, <xref:System.Buffers.ArrayPool%601> puede usarse para evitar las asignaciones repetidas y la presión de memoria que se incluye en ellos:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Unicode)]
private static extern unsafe void Foo([Out] char[] buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    char[] buffer = ArrayPool<char>.Shared.Rent(BufferSize);
    try
    {
        int len = buffer.Length;
        Foo(buffer, ref len);
        string result = new string(buffer);
    }
    finally
    {
        ArrayPool<char>.Shared.Return(buffer);
    }
}
```

Si no se conoce el tamaño del búfer hasta el tiempo de ejecución, es posible que sea necesario crear el búfer de manera diferente en función del tamaño para evitar la asignación de búferes de gran tamaño con `stackalloc` .

En los ejemplos anteriores se utilizan caracteres anchos de 2 bytes ( `CharSet.Unicode` ). Si la función nativa usa caracteres de 1 byte ( `CharSet.Ansi` ), `byte` se puede utilizar un búfer en lugar de un `char` búfer. Por ejemplo:

```csharp
[DllImport("MyLibrary", CharSet = CharSet.Ansi)]
private static extern unsafe void Foo(byte* buffer, ref int length);

public void Bar()
{
    int BufferSize = ...
    unsafe
    {
        byte* buffer = stackalloc byte[BufferSize];
        int len = BufferSize;
        Foo(buffer, ref len);
        string result = Marshal.PtrToStringAnsi((IntPtr)buffer);
    }
}
```

Si el parámetro también se usa como entrada, los búferes se deben rellenar con los datos de cadena con cualquier terminador nulo agregado explícitamente.

## <a name="when-to-suppress-warnings"></a>Cuándo suprimir advertencias

Suprima una infracción de esta regla si no le preocupa el impacto en el rendimiento de la serialización de un `StringBuilder` .

## <a name="see-also"></a>Consulte también

- [Advertencias de rendimiento](../code-quality/performance-warnings.md)
- [Procedimientos recomendados de interoperabilidad nativa](/dotnet/standard/native-interop/best-practices)
- <xref:System.Buffers.ArrayPool%601>
- [stackalloc](/dotnet/csharp/language-reference/operators/stackalloc)
- [Juegos](/dotnet/standard/native-interop/charset)
