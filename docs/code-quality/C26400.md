---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016618"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Esta comprobación ayuda a aplicar el @no__t 0rule: Nunca transfiera la propiedad mediante un puntero sin formato (T @ no__t-0) *, que es un subconjunto de la regla *R. 3: Un puntero sin formato (a T @ no__t-0) no es propietario.* En concreto, advierte sobre cualquier llamada a Operator `new`, que guarda su resultado en una variable de tipo de puntero sin formato. También advierte sobre las llamadas a funciones que devuelven `gsl::owner<T>` si sus resultados se asignan a punteros sin formato. La idea es que debe indicar claramente la propiedad de los recursos de memoria. Para obtener más información, consulte las [ C++ directrices básicas](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

La forma más fácil de solucionarlo es usar la declaración `auto` si el recurso se asigna inmediatamente en la declaración de la variable. Si esto no es posible, se recomienda usar el tipo `gsl::owner<T>`. Las declaraciones `auto` inicializadas con el operador `new` son "propietarios" porque suponemos que el resultado de cualquier asignación es implícitamente un puntero propietario. Transferimos esta suposición a la variable `auto` y la trataremos como `owner<T>`.

Si esta comprobación marca una llamada a una función que devuelve `owner<T>`, puede ser una indicación de un error legítimo en el código. Básicamente, apunta a un lugar donde el código pierde una noción explícita de propiedad (y quizás el propio recurso).

## <a name="remarks"></a>Comentarios

Esta regla actualmente solo comprueba las variables locales. Si la asignación se asigna a un parámetro formal, una variable global, un miembro de clase, etc., no se marca. La cobertura adecuada de estos escenarios es parte del trabajo futuro.

## <a name="example-1-simple-allocation"></a>Ejemplo 1: Asignación simple

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Ejemplo 2: Asignación simple (corregida con GSL:: Owner @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
