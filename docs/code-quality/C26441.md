---
title: C26441
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 329edccc1aad1cd16d193a8baeb8cb5e631bc4b7
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/15/2020
ms.locfileid: "77265499"
---
# <a name="c26441-no_unnamed_guards"></a>NO_UNNAMED_GUARDS C26441

"Los objetos de protección deben tener nombre".

Directrices básicas: CP. 44: Recuerde asignar un nombre a la lock_guards y unique_locks **C++**

La biblioteca estándar proporciona algunas clases útiles que ayudan a controlar el acceso simultáneo a los recursos. Los objetos de estos tipos bloquean el acceso exclusivo mientras dure su vigencia. Esto implica que todos los objetos de bloqueo deben tener un nombre, es decir, tener claramente definida una duración que abarca el período en el que se ejecutan las operaciones de acceso. Por lo tanto, no asignar un objeto de bloqueo a una variable es un error que deshabilita el mecanismo de bloqueo (ya que las variables temporales son transitorias). Esta regla intenta detectar casos simples de este comportamiento no previsto.

## <a name="remarks"></a>Observaciones

- Solo se realiza el seguimiento de los tipos de bloqueo estándar: STD:: scoped_lock, STD:: unique_lock y STD:: lock_quard.
  - Solo se analizan las llamadas simples a los constructores. Una expresión de inicializador más compleja puede dar lugar a resultados inexactos, pero esto es en realidad un escenario inusual.
  - Los bloqueos que se pasan como argumentos a las llamadas de función o se devuelven como resultado de las llamadas a funciones se omiten.
  - Los bloqueos creados como objetos temporales pero asignados a referencias con nombre para ampliar su duración se omiten.

## <a name="example"></a>Ejemplo

falta una variable de ámbito

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

falta el ámbito variable: corregido

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```
