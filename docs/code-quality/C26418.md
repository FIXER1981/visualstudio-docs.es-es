---
title: C26418| Microsoft Docs
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26418
helpviewer_keywords:
- C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ccdd2170d083ca73f833667974353372c6f89545
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011380"
---
# <a name="c26418-no_value_or_const_ref_shared_ptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
"El parámetro de puntero compartido no se copia ni se mueve. Use T * o T & en su lugar ".

Directrices básicas: R. 36: toma de un\<de shared_ptr del widget > & para expresar que podría conservar un recuento de referencias en el objeto **C++**

Si el parámetro de puntero compartido se pasa por valor o referencia a un objeto constante, se espera que la función tome el control de la duración del objeto de destino sin que se vea afectado el autor de la llamada. El código debe copiar o trasladar el parámetro de puntero compartido a otro objeto de puntero compartido o pasarlo a otro código mediante la invocación de funciones que aceptan punteros compartidos. Si no es así, es posible que el puntero o la referencia sin formato sean factibles.

## <a name="remarks"></a>Comentarios
- Esta comprobación reconoce STD:: shared_pointer y los tipos definidos por el usuario que es probable que se comporten como punteros compartidos. Se esperan los siguientes rasgos para los punteros compartidos definidos por el usuario:
- la desreferenciación sobrecargada o los operadores de acceso a miembros (públicos y no eliminados);
- constructor de copias o operador de asignación de copia (público y no eliminado);
- Destructor público que no se ha eliminado ni predeterminado. Los destructores vacíos se siguen contando como definidos por el usuario.

## <a name="example"></a>Ejemplo
complicación de interfaz innecesaria

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Ejemplo
complicación de interfaz innecesaria: simplificada

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```
